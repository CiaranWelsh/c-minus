WEBVTT

1
00:00:07.860 --> 00:00:12.850
Francisco.Ortin@cit.ie: Hi, welcome everyone to… programming languages I am lectured to.

2
00:00:13.270 --> 00:00:19.090
Francisco.Ortin@cit.ie: So today's lecture is going to be about lexical analysis, which is, as you saw in Lecture 1,

3
00:00:19.260 --> 00:00:24.060
Francisco.Ortin@cit.ie: The first module in, language recognizer.

4
00:00:26.840 --> 00:00:32.780
Francisco.Ortin@cit.ie: Okay, so first we're gonna take a look at the objectives of Lexical Analyzer.

5
00:00:33.180 --> 00:00:38.390
Francisco.Ortin@cit.ie: So we think in, language recognizes as a… Program.

6
00:00:39.200 --> 00:00:43.320
Francisco.Ortin@cit.ie: Then the architecture It's divided into different,

7
00:00:43.490 --> 00:00:46.079
Francisco.Ortin@cit.ie: modules that we saw in Lecture 1.

8
00:00:46.920 --> 00:00:53.230
Francisco.Ortin@cit.ie: So, in order to make sure you understand the responsibilities of each module.

9
00:00:53.370 --> 00:00:57.370
Francisco.Ortin@cit.ie: And then being able to, analyze what's inside of it.

10
00:00:57.520 --> 00:01:02.690
Francisco.Ortin@cit.ie: It's very important to know which are the requirements or the objectives of each,

11
00:01:02.860 --> 00:01:17.010
Francisco.Ortin@cit.ie: module, in this case, lexical analysis, okay? First part, always, of all the units we have is being able to identify and understand the responsibilities of each module.

12
00:01:17.170 --> 00:01:21.839
Francisco.Ortin@cit.ie: as somehow you did answering the questions in Lecture 1 and Lab 1.

13
00:01:22.760 --> 00:01:29.999
Francisco.Ortin@cit.ie: Then we're going to take a look at how, something related to definition, and it's always going to be exactly the same in all the modules.

14
00:01:30.210 --> 00:01:35.099
Francisco.Ortin@cit.ie: So, which are the tools we have to define lexical analysis?

15
00:01:35.300 --> 00:01:42.420
Francisco.Ortin@cit.ie: Once we've kind of, fluent with those tools, in this case, we're going to use, firmament languages.

16
00:01:42.560 --> 00:01:48.539
Francisco.Ortin@cit.ie: Then we're gonna see how to implement it using one tool called Antler.

17
00:01:48.700 --> 00:01:54.820
Francisco.Ortin@cit.ie: Anthra generates different languages, but again, I'm gonna just focus on Java programming language, so it's like…

18
00:01:54.970 --> 00:01:57.450
Francisco.Ortin@cit.ie: Responsibilities or objectives?

19
00:01:58.160 --> 00:02:06.230
Francisco.Ortin@cit.ie: design, and then implementation, all right? So again, implementation and design, they're highly connected with labs, all right?

20
00:02:06.990 --> 00:02:07.720
Francisco.Ortin@cit.ie: Good.

21
00:02:08.130 --> 00:02:22.100
Francisco.Ortin@cit.ie: So, try to remember that the lexical analysis is the first phase of a language translator that reads an input many times, or most of the times as a sequence of characters. It could be also binary.

22
00:02:22.430 --> 00:02:26.650
Francisco.Ortin@cit.ie: And, sometimes even visual, and then generates,

23
00:02:26.870 --> 00:02:30.369
Francisco.Ortin@cit.ie: A sequence of tokens, so it's dividing this input.

24
00:02:30.550 --> 00:02:37.370
Francisco.Ortin@cit.ie: into more, A more appropriate way of,

25
00:02:38.210 --> 00:02:43.870
Francisco.Ortin@cit.ie: item that is going to be used by the syntax analysis or parser, okay?

26
00:02:44.400 --> 00:02:50.410
Francisco.Ortin@cit.ie: So the formal definition of token is the minimum meaningful unit to be used by departure.

27
00:02:50.870 --> 00:02:57.849
Francisco.Ortin@cit.ie: again, this is so, formal, and I think it's better to think as I've been, like,

28
00:02:58.210 --> 00:02:59.920
Francisco.Ortin@cit.ie: words in English.

29
00:03:00.070 --> 00:03:06.300
Francisco.Ortin@cit.ie: And you get the characters, once you realize this is a word, then this is, gonna be a token,

30
00:03:07.580 --> 00:03:10.360
Francisco.Ortin@cit.ie: Noun, or article, or…

31
00:03:10.920 --> 00:03:21.459
Francisco.Ortin@cit.ie: programming language, it's going to be identifier, or it's going to be semicolon, or it's going to be plus plus incremental operator, right?

32
00:03:22.120 --> 00:03:23.820
Francisco.Ortin@cit.ie: Those are tokens.

33
00:03:24.500 --> 00:03:33.899
Francisco.Ortin@cit.ie: Also, an important objective of lexical analysis is discarding or getting rid of meaningless characters.

34
00:03:34.070 --> 00:03:37.269
Francisco.Ortin@cit.ie: So, in most languages, when you have a new line.

35
00:03:37.780 --> 00:03:54.029
Francisco.Ortin@cit.ie: new line means nothing. It's just something the programmer adds to make the program more readable. Python is a counter example, but most languages, new line means nothing. So you can write, something like,

36
00:03:55.460 --> 00:03:57.589
Francisco.Ortin@cit.ie: In Java, for instance, again.

37
00:04:01.750 --> 00:04:02.930
Francisco.Ortin@cit.ie: You can ride.

38
00:04:03.190 --> 00:04:09.010
Francisco.Ortin@cit.ie: A assigned B, and then… The,

39
00:04:10.280 --> 00:04:13.960
Francisco.Ortin@cit.ie: 2 times A. Okay, you can write in the same line.

40
00:04:14.140 --> 00:04:21.720
Francisco.Ortin@cit.ie: For the syntax Analyzer, this is exactly the same. So this new line here is just going to be discarded by the lecture, all right?

41
00:04:22.610 --> 00:04:25.260
Francisco.Ortin@cit.ie: The same happens with spaces here.

42
00:04:25.370 --> 00:04:38.160
Francisco.Ortin@cit.ie: All right? These spaces doesn't change anything, so it doesn't matter to the parser you write this or this, okay? It's the legs are the one that's going to be discarded in the blanks, right? The same with comments.

43
00:04:39.280 --> 00:04:47.529
Francisco.Ortin@cit.ie: All right? Most languages' comments are just discarded by the lexical analyzer. Again, some Python comments are not, but

44
00:04:47.730 --> 00:04:54.149
Francisco.Ortin@cit.ie: Some of them are, alright? So it depends on the comments. I'm not gonna go deeper in Python. In case you're interested, you can ask me, but…

45
00:04:54.390 --> 00:04:57.319
Francisco.Ortin@cit.ie: I'm just, trying to stay with Java.

46
00:04:57.910 --> 00:04:59.450
Francisco.Ortin@cit.ie: All right.

47
00:04:59.620 --> 00:05:01.490
Francisco.Ortin@cit.ie: Also, taddy Lars, of course.

48
00:05:01.920 --> 00:05:17.940
Francisco.Ortin@cit.ie: Well, how are tokens represented? Well, mostly by integers. So if you have the token, here, this is an identifier, it's going to be a number that, reco… well, is associated to any identifier. So the token

49
00:05:18.200 --> 00:05:22.020
Francisco.Ortin@cit.ie: type of A and B is going to be the same one, all right?

50
00:05:22.400 --> 00:05:38.979
Francisco.Ortin@cit.ie: However, we will have more information than just the token to tell A from B, of course, okay? But the type of the token is exactly the same. It's the same in English. You have, like, two articles, and they're just identified or classified as articles, right? So that's exactly the same.

51
00:05:40.220 --> 00:05:44.090
Francisco.Ortin@cit.ie: Here we have an example.

52
00:05:44.410 --> 00:05:48.130
Francisco.Ortin@cit.ie: This is a typical while loop in a C-based language.

53
00:05:48.230 --> 00:05:53.569
Francisco.Ortin@cit.ie: Where you have, This keyword, then a blank here.

54
00:05:53.730 --> 00:05:59.309
Francisco.Ortin@cit.ie: Then, an expression that in this language particularly, must be between parentheses.

55
00:05:59.640 --> 00:06:01.349
Francisco.Ortin@cit.ie: And then here's some blanks.

56
00:06:01.490 --> 00:06:03.899
Francisco.Ortin@cit.ie: Right? And then here, a comment.

57
00:06:04.080 --> 00:06:05.989
Francisco.Ortin@cit.ie: So in this case, this loop.

58
00:06:06.270 --> 00:06:17.590
Francisco.Ortin@cit.ie: has 41 characters, if you wish, integers, all right? Because, as you know, in most private languages, and of course in Java, characters promote to integer.

59
00:06:19.270 --> 00:06:29.789
Francisco.Ortin@cit.ie: So the tokens you have here is, first one, the keyword while. Again, I'm using this instead of number because it's more readable. Remember, in Java.

60
00:06:29.940 --> 00:06:36.449
Francisco.Ortin@cit.ie: uppercase, Identifiers represent constants, right?

61
00:06:36.580 --> 00:06:51.939
Francisco.Ortin@cit.ie: Then the ASCII code, which is another number of open parentheses, is the next token. Then A is identifier, as I told you in the previous slide. Doesn't really matter, it's A or B. Then plus plus cannot be used… here is… this is an interesting one.

62
00:06:53.530 --> 00:07:01.290
Francisco.Ortin@cit.ie: it could be… it could have been recognized as two plus operators, plus and then plus. As you know.

63
00:07:01.420 --> 00:07:14.249
Francisco.Ortin@cit.ie: the operator plus, when you use it twice, is not the same as using plus plus, all right? So this is an ambiguity lexer must be careful with, all right? In other words, when we have plus plus.

64
00:07:14.980 --> 00:07:25.040
Francisco.Ortin@cit.ie: we can ask ourselves, okay, are we… are we meaning, as a programmer, incremental, as I'm doing here? Or actually, do I mean,

65
00:07:25.280 --> 00:07:36.020
Francisco.Ortin@cit.ie: plus twice. In this case, I must write this one here, all right? So this is ambiguous, actually. Firmly speaking, both are correct, but this ambiguity should be broken

66
00:07:36.060 --> 00:07:45.890
Francisco.Ortin@cit.ie: By the lecture, all right? So here, we'll… we'll speak about that much later. This is increment, okay?

67
00:07:47.780 --> 00:07:56.749
Francisco.Ortin@cit.ie: Then this is lower or equal to, characters, so that's why I need a number here, because I cannot use the ASCII code, identifier, and so on and so on.

68
00:07:57.030 --> 00:07:59.410
Francisco.Ortin@cit.ie: You can see how comments are discarded.

69
00:08:00.020 --> 00:08:00.800
Francisco.Ortin@cit.ie: Okay?

70
00:08:01.100 --> 00:08:11.190
Francisco.Ortin@cit.ie: Well, again, when I'm using apostrophe this, I'm taking a character that promotes into an integer, so actually I'm taking the ASCII code for this character.

71
00:08:13.510 --> 00:08:16.770
Francisco.Ortin@cit.ie: Is there any questions? Are there any questions there?

72
00:08:18.240 --> 00:08:18.910
Francisco.Ortin@cit.ie: No?

73
00:08:19.940 --> 00:08:21.080
Francisco.Ortin@cit.ie: So,

74
00:08:26.210 --> 00:08:43.280
Francisco.Ortin@cit.ie: Oh, sorry, I think I have muted some students. Sorry, if you have a question, can you please unmute and ask the question, please, if you don't mind? Sorry, I thought there were kind of noises, so that's why I muted your mic. Okay, so in case you have any question, just enable that and shoot. All right?

75
00:08:43.820 --> 00:08:48.129
Francisco.Ortin@cit.ie: Okay, so here, the characters are being discarded by

76
00:08:48.880 --> 00:08:52.170
Francisco.Ortin@cit.ie: The legs are blanks, as you can see here.

77
00:08:53.010 --> 00:08:55.249
Francisco.Ortin@cit.ie: Okay? Then, new lines.

78
00:08:55.560 --> 00:08:58.010
Francisco.Ortin@cit.ie: And then all the comments.

79
00:09:00.120 --> 00:09:03.170
Francisco.Ortin@cit.ie: And I think nothing else here, alright?

80
00:09:03.980 --> 00:09:07.830
Francisco.Ortin@cit.ie: A tabular as well, okay? So if you're here, you have a tabular, it's also deleted.

81
00:09:08.380 --> 00:09:11.459
Francisco.Ortin@cit.ie: Okay, but something very important is…

82
00:09:13.070 --> 00:09:23.630
Francisco.Ortin@cit.ie: It many times causes a misunderstanding for some programmers, which is what is… what is actually a new line character, where actually there's no such thing, all right?

83
00:09:23.650 --> 00:09:34.130
Francisco.Ortin@cit.ie: There's nothing like Newline character. And this is because, again, as always in computer science and many, many scenarios, history, shows you that

84
00:09:34.150 --> 00:09:44.069
Francisco.Ortin@cit.ie: different people doing the same, the same thing sometimes causes, dissimilarities, okay? And we have to deal with that.

85
00:09:44.140 --> 00:09:45.900
Francisco.Ortin@cit.ie: So…

86
00:09:46.010 --> 00:10:04.870
Francisco.Ortin@cit.ie: This, new line concept comes from printers, alright, long time ago. And printers, they have, like, a line fit that is, going to the new line, so going from this line down here, like that, and then carriage return that was taking this line and going to the starting point, okay?

87
00:10:05.210 --> 00:10:14.790
Francisco.Ortin@cit.ie: So, as those characters were sent to the printer, they needed two different, two different bytes, okay? So,

88
00:10:15.340 --> 00:10:24.709
Francisco.Ortin@cit.ie: there's one byte call, and the asking table is 13, there is carrots return, that's… whatever you are in the line, you go to the beginning of the line, okay? Like the…

89
00:10:24.990 --> 00:10:33.809
Francisco.Ortin@cit.ie: all typewriters, and then line fit is going down, alright? So this means that for these historical reasons, because of, of,

90
00:10:34.640 --> 00:10:52.520
Francisco.Ortin@cit.ie: of printers, Windows operating system, the default new line mapping is first ASCII code 13, and then 10, which is buggy slash N, all right? So actually, if you take a Windows text file, and you edit it in binary.

91
00:10:52.720 --> 00:10:58.520
Francisco.Ortin@cit.ie: then you'll see that you have two bytes, first 13, and then 10, okay?

92
00:10:59.500 --> 00:11:10.940
Francisco.Ortin@cit.ie: And that's for Windows, so many times, if you take that text and you try to open in Unix or any version of Unix, like Linux or macOS, then…

93
00:11:11.150 --> 00:11:20.949
Francisco.Ortin@cit.ie: you may have trouble, so it depends on the quality of the editor. Nowadays, I think most of them support all the different combinations, but I remember a long time ago when there were issues.

94
00:11:21.540 --> 00:11:27.069
Francisco.Ortin@cit.ie: Okay, in Unix, they use just new character as ASCII code, say, line 3.

95
00:11:27.440 --> 00:11:33.599
Francisco.Ortin@cit.ie: In Java, there's this character here that is Line fade.

96
00:11:33.840 --> 00:11:49.320
Francisco.Ortin@cit.ie: But you also have this one here that is character churn, okay? And when you're implementing Alexa, you have to be aware that any combination of these two characters are allowed in different operating systems. For instance, old-fashioned Mac OS 9 and before, they use

97
00:11:49.320 --> 00:12:00.419
Francisco.Ortin@cit.ie: only character 13. There's a version that is, 10 and then 13, but I don't remember right now, okay? It's very, very old-fashioned. Probably you'll never find a text like that, a text slide like that.

98
00:12:00.470 --> 00:12:17.740
Francisco.Ortin@cit.ie: So, in other words, when you're implementing Alexa, you have to consider all the combinations of these two bytes or characters. They're actually characters, okay? So, hey, there's no such thing like new line. Many times we say new line, but actually, if you're thinking in binary, it's… it may be one byte

99
00:12:17.740 --> 00:12:29.110
Francisco.Ortin@cit.ie: two bytes, and if it's one byte, it could be 13 or 10, okay? So it's… you have to be careful with that when you're, formally describing your web search. So, for instance, if you come from macOS,

100
00:12:29.110 --> 00:12:33.360
Francisco.Ortin@cit.ie: you have to consider this one. If you're coming from Windows, you have to consider this too.

101
00:12:33.360 --> 00:12:35.970
Francisco.Ortin@cit.ie: And so on and so forth. Alright? Be careful with that.

102
00:12:37.240 --> 00:12:44.569
Francisco.Ortin@cit.ie: Good. So, how do we represent these uppercased, constants, which are integers in Java?

103
00:12:44.720 --> 00:12:52.220
Francisco.Ortin@cit.ie: Well, you can think about it. This is, like, a very, easy programming question. You can write it in the chat or say it aloud.

104
00:12:52.510 --> 00:12:59.389
Francisco.Ortin@cit.ie: I don't wanna, you know, it's very basic, it's just writing public final static, okay?

105
00:13:00.100 --> 00:13:15.860
Francisco.Ortin@cit.ie: So this is how these are going to be mapped into code, okay? So every time I write this, you have to think that there's going to be one class that has log equal as public static final int, and then one number is going to be assigned to it, okay? That number is,

106
00:13:15.860 --> 00:13:20.350
Francisco.Ortin@cit.ie: Greater than 252, so that I can use these ASCII codes.

107
00:13:20.400 --> 00:13:31.340
Francisco.Ortin@cit.ie: For any token, okay? So I don't have to define them, like, closing parentheses or something like that is very, very long. All right? Any, any questions you may have, just…

108
00:13:31.880 --> 00:13:37.559
Francisco.Ortin@cit.ie: Ask me, or if you wish, you prefer, you can write it in the chat, I'll take a look once in a while.

109
00:13:39.250 --> 00:13:58.260
Francisco.Ortin@cit.ie: Okay, so as I said, a token is the minimum meaningful unit to be used by the parser. So, there are many examples of tokens. For instance, keywords are tokens, very important. There's no keyword token. There are different tokens for each keyword. So, while itself is a token, which is different from

110
00:13:58.710 --> 00:14:01.149
Francisco.Ortin@cit.ie: if and read and end, okay?

111
00:14:01.820 --> 00:14:07.990
Francisco.Ortin@cit.ie: I'm using read and write for C minus minus input and output, okay? So,

112
00:14:08.220 --> 00:14:17.459
Francisco.Ortin@cit.ie: when you read from the keyword, the user writes something in the… or types something in the keyword, and then it's read. And writing is the same as printing, all right?

113
00:14:18.000 --> 00:14:23.559
Francisco.Ortin@cit.ie: Then, any identifier, is classified with the token ID.

114
00:14:24.010 --> 00:14:29.730
Francisco.Ortin@cit.ie: Then we have, different operators, those that have just, one character length.

115
00:14:30.050 --> 00:14:36.760
Francisco.Ortin@cit.ie: could use the ASCII code as this one, as this one, but if you have two or more, then you need a new,

116
00:14:36.890 --> 00:14:40.720
Francisco.Ortin@cit.ie: Public final static constants, all right?

117
00:14:41.740 --> 00:14:45.649
Francisco.Ortin@cit.ie: The same happens with inconstant and car constant, okay? These are…

118
00:14:46.150 --> 00:14:53.409
Francisco.Ortin@cit.ie: Literals, okay? If you, if you think about constant or literal, here they're exactly synonyms, okay?

119
00:14:54.000 --> 00:15:02.229
Francisco.Ortin@cit.ie: So, if you write 122, that's gonna be, in constant token, which is recognized, okay?

120
00:15:02.490 --> 00:15:08.389
Francisco.Ortin@cit.ie: So I know… I know a definition here is… The definition of laxing.

121
00:15:08.630 --> 00:15:12.859
Francisco.Ortin@cit.ie: So lexin… lexin is the group of characters that form a token.

122
00:15:13.310 --> 00:15:27.510
Francisco.Ortin@cit.ie: So, Alexa is gonna be analyzing the input, Until it recognizes a token, Because the sequence of characters

123
00:15:27.860 --> 00:15:47.720
Francisco.Ortin@cit.ie: are described by the language designer as a token. So here, if you have lowercase w-H-I-L-E, then this is going to be represented as a keyword. But the difference that, sorry, keyword, oh my gosh, wild keyword. Difference between the token and the Lexim is that the token is just an integer.

124
00:15:47.800 --> 00:15:50.810
Francisco.Ortin@cit.ie: And the lexin is a sequence of characters, all right?

125
00:15:50.940 --> 00:16:01.489
Francisco.Ortin@cit.ie: So here, for all those four keywords, those aren't the only, the only, valid lexins, because our language is case-sensitive, okay? So everything has to be lowercased.

126
00:16:01.790 --> 00:16:17.919
Francisco.Ortin@cit.ie: However, if you focus on ID, then there are many different examples. It may be just A, factorial, letters, or var 1, okay? So you can see here how for one token, there could be just one simple Lexim, but

127
00:16:17.970 --> 00:16:27.089
Francisco.Ortin@cit.ie: Another case scenario is one, token, like ID, may have many different, alternatives, or many different, lexins, all right?

128
00:16:27.740 --> 00:16:32.049
Francisco.Ortin@cit.ie: The same here for, these operators, okay?

129
00:16:33.130 --> 00:16:37.560
Francisco.Ortin@cit.ie: Then, for integer constants, we might have 32, and take a look at this one.

130
00:16:37.840 --> 00:16:47.320
Francisco.Ortin@cit.ie: A car constant, how do we write car constants in Java? So if you want to say that C is going to be assigned the car constant H, you need to write it this way.

131
00:16:47.350 --> 00:17:05.260
Francisco.Ortin@cit.ie: So you can see how the lexim of a carb constant takes 3 characters, okay? Be careful with those details. They're very obvious when you're programming, but when you're defining a formal lexer, you have to be so careful with it, all right?

132
00:17:05.599 --> 00:17:19.760
Francisco.Ortin@cit.ie: So here, the number of characters in the Lexi are 3. 1, 2, 3. So apostrophe A, apostrophe are the three characters in this particular case scenario associated to this car constant, okay?

133
00:17:20.050 --> 00:17:24.590
Francisco.Ortin@cit.ie: Remember that in Java, you can only write here one character. You cannot write, like.

134
00:17:24.710 --> 00:17:34.860
Francisco.Ortin@cit.ie: Python string, okay? That's… that's not Java. That's in Java, and if you want to do that, you have to use this quotation, character, okay? Again, any questions you may have.

135
00:17:35.040 --> 00:17:36.659
Francisco.Ortin@cit.ie: Yes, ask me.

136
00:17:36.660 --> 00:17:38.030
Jaume Mesquida Lanas: I have a question.

137
00:17:38.030 --> 00:17:38.740
Francisco.Ortin@cit.ie: Yes.

138
00:17:39.220 --> 00:17:43.770
Jaume Mesquida Lanas: So For example, can you put, rain back the…

139
00:17:44.780 --> 00:17:45.669
Francisco.Ortin@cit.ie: This one here?

140
00:17:45.670 --> 00:17:48.310
Jaume Mesquida Lanas: Yes, please. So, for example, 34.

141
00:17:48.870 --> 00:17:54.620
Jaume Mesquida Lanas: in a token has two values, right? You have the int constant, like the type.

142
00:17:55.010 --> 00:17:58.229
Jaume Mesquida Lanas: And you have to shave the value 34.

143
00:17:58.230 --> 00:18:04.560
Francisco.Ortin@cit.ie: Yeah, exactly. So, actually, what matters here, believe it or not, is the token. The token is,

144
00:18:05.010 --> 00:18:17.229
Francisco.Ortin@cit.ie: is one number, okay? It doesn't really matter, because the tool is going to associate a consecutive number to it, so we don't care about it, okay? And this is what is called Lexing.

145
00:18:17.520 --> 00:18:28.319
Francisco.Ortin@cit.ie: Okay, what we're gonna do in the implementation is, okay, since this is an integer constant, we're gonna take the leg sim and store it at the same time as we have this one.

146
00:18:28.330 --> 00:18:41.439
Francisco.Ortin@cit.ie: store it somewhere else, and also converting to an integer, because, okay, this is an integer, it doesn't really make sense to keep, storing that as string, okay? So, if you want to do an optimization and increment something or something.

147
00:18:41.440 --> 00:18:50.290
Francisco.Ortin@cit.ie: So you're gonna, you're gonna, store both pins. So this one is the one that is actually important right now, but yeah, yes,

148
00:18:51.600 --> 00:19:02.390
Francisco.Ortin@cit.ie: you have to somehow remember that, it's not just a token, but we all… we're also gonna somehow store the associated lexin, okay? Is that clear, Jama?

149
00:19:02.390 --> 00:19:05.160
Jaume Mesquida Lanas: Yes, okay, so the token is only the type.

150
00:19:05.560 --> 00:19:06.070
Jaume Mesquida Lanas: And then…

151
00:19:06.070 --> 00:19:24.540
Francisco.Ortin@cit.ie: The token, yeah, it's… is… you may say the type, yeah, that's it. Actually, there, there, you don't say token type, it's just a token, okay? But it's better for you just saying, okay, I want to tell… I want to tell this… this guy here from this one here, this is, like, the type, and this is the leg scene, okay? This is the instance, if you wish.

152
00:19:24.980 --> 00:19:26.280
Jaume Mesquida Lanas: Yeah, yeah.

153
00:19:26.280 --> 00:19:27.290
Francisco.Ortin@cit.ie: Okay, thank you very much.

154
00:19:27.290 --> 00:19:27.980
Jaume Mesquida Lanas: Thank you.

155
00:19:29.590 --> 00:19:32.680
Francisco.Ortin@cit.ie: So, now that we're,

156
00:19:33.100 --> 00:19:38.200
Francisco.Ortin@cit.ie: Just taking a look at the objectives of the lexical analysis.

157
00:19:38.500 --> 00:19:50.629
Francisco.Ortin@cit.ie: and we know what a lexim and what a token is, we may rephrase the objective of a lecture. So, the objective of a lecture is to recognize lexins.

158
00:19:50.840 --> 00:19:55.950
Francisco.Ortin@cit.ie: and return the appropriate token, as somehow I was debating with Jalma, okay?

159
00:19:56.100 --> 00:20:02.380
Francisco.Ortin@cit.ie: So that's actually what's… what's gonna happen, okay? So it's like, you have an input, I start reading the characters.

160
00:20:02.600 --> 00:20:18.800
Francisco.Ortin@cit.ie: probably the first one may be a comment, so I just discard the whole line, and then the first one is a class, for instance, a class keyword. So I take CLASS, and then I return class keyword, and I keep doing the same algorithm again and again, okay?

161
00:20:18.980 --> 00:20:30.439
Francisco.Ortin@cit.ie: So this is how it works from the outside. This is the objective, or the responsibility, main responsibility, but now the question is, okay, if I want to go inside that box, how do I do that?

162
00:20:30.550 --> 00:20:34.509
Francisco.Ortin@cit.ie: Okay, how can we possibly specify its behavior?

163
00:20:34.510 --> 00:20:47.179
Francisco.Ortin@cit.ie: So the way we do that is by using patterns, okay? So the pattern is gonna… I'm going back, is gonna say, okay, every time you read a W, then H, then I, L, and E,

164
00:20:47.180 --> 00:20:55.629
Francisco.Ortin@cit.ie: this, no matter what, is gonna be this one here. So you're gonna specify the pattern of the leg sim and the associated token, okay? This is the…

165
00:20:55.680 --> 00:20:59.090
Francisco.Ortin@cit.ie: Design level, this is the formalism we're gonna use.

166
00:20:59.090 --> 00:21:22.150
Francisco.Ortin@cit.ie: And then if you're able to state that in some language, there's going to be a tool that takes that and implements all the Java code for you, okay? Of course, for a while, it's very simple, just 5 lowercase letters. But if you're thinking an ID, well, it's not complicated, but it's not that simple, because it could be many different characters, do I allow any letter, or just digits and alphanumeric? Well.

167
00:21:22.330 --> 00:21:27.810
Francisco.Ortin@cit.ie: something we have to debate later, alright? So sometimes it's very easy, sometimes it's not.

168
00:21:28.030 --> 00:21:38.340
Francisco.Ortin@cit.ie: And Dimitra's asking, looks like a job for regular S. Exactly. Regular expressions are a formalism that could be used, and that's exactly what we are about to take a look at, all right?

169
00:21:38.480 --> 00:21:46.359
Francisco.Ortin@cit.ie: Regular expressions and context-free grammars as… Formal languages for pattern description.

170
00:21:46.820 --> 00:21:55.510
Francisco.Ortin@cit.ie: could be used and actually are, actually used in the implementation of real language, processors. Very good.

171
00:21:57.370 --> 00:22:02.680
Francisco.Ortin@cit.ie: So, this is something that is very famous in…

172
00:22:02.950 --> 00:22:08.120
Francisco.Ortin@cit.ie: Computer science, and also outside computer science, and to language studies.

173
00:22:10.620 --> 00:22:14.420
Francisco.Ortin@cit.ie: That's why it's called the Nam-Chonsky hierarchy.

174
00:22:15.290 --> 00:22:24.029
Francisco.Ortin@cit.ie: So this guy, a long time ago, described firmly different type of languages, all right? And their, their

175
00:22:24.730 --> 00:22:36.380
Francisco.Ortin@cit.ie: subsets one of another one. So the type 0 is the one with the most expressive one, okay, and includes the rest of them. Includes type 1, type 2, and type 3.

176
00:22:36.680 --> 00:22:44.330
Francisco.Ortin@cit.ie: Similarly, Type 3 are the least expressive ones, on… they're…

177
00:22:44.820 --> 00:22:50.730
Francisco.Ortin@cit.ie: particular case scenario of type 2, and the same way in a transitive way, okay?

178
00:22:51.880 --> 00:23:06.839
Francisco.Ortin@cit.ie: So, many students, when they take a look at this first time, they say, okay, if this is the most powerful one, why don't we just bother about the other three and take always this one here, because it's the most powerful one? So it's the one that allows you to write

179
00:23:06.840 --> 00:23:14.170
Francisco.Ortin@cit.ie: any programming language or any data format. That is what is called Turing Complaint, okay? That's a very good question.

180
00:23:14.560 --> 00:23:32.839
Francisco.Ortin@cit.ie: However, if you take this type 0, and you're trying to implement a language recognizer for this language, it's going to be very, very slow at runtime. It's not efficient, okay? It's very expensive, concerning to… or related to, CPU, memory consumption.

181
00:23:32.960 --> 00:23:39.229
Francisco.Ortin@cit.ie: However, if you take these ones here, these are the fastest, this level is the fastest one, all right?

182
00:23:39.690 --> 00:23:53.350
Francisco.Ortin@cit.ie: So, performance is always an issue. Performance is always important, so you have to always try to get the fastest, approach that is able to give you the expressiveness you need, all right?

183
00:23:53.910 --> 00:24:04.669
Francisco.Ortin@cit.ie: Good. So, the fastest one and the least expensive one are regular languages. Many, many languages have been implemented using regular expressions, all right?

184
00:24:04.770 --> 00:24:15.250
Francisco.Ortin@cit.ie: Flex, for instance, is a very famous tool that allows you to do that. But there are particular, particular things, that,

185
00:24:15.410 --> 00:24:29.199
Francisco.Ortin@cit.ie: of programming languages that you cannot actually do with… from the lexical point of view, sorry, and remember that we're in lexical analysis, that you cannot actually do with regular expressions. So Flex has, like, some

186
00:24:29.420 --> 00:24:35.530
Francisco.Ortin@cit.ie: extensions that allow you to… to use something, Type 2, alright?

187
00:24:35.840 --> 00:24:48.619
Francisco.Ortin@cit.ie: Then, type 2 are widely used for syntax analysis, okay? And in the last, I would say, decade or two decades, probably just one decade, it's also used for,

188
00:24:49.080 --> 00:24:51.449
Francisco.Ortin@cit.ie: lexical analysis.

189
00:24:51.680 --> 00:24:56.060
Francisco.Ortin@cit.ie: Okay? So you can write both parser and Lexer in this level.

190
00:24:56.520 --> 00:24:57.259
Francisco.Ortin@cit.ie: All right?

191
00:24:57.530 --> 00:25:13.040
Francisco.Ortin@cit.ie: This is actually the level we're gonna use. We're gonna just, remember something about regular expressions, take a look at how powerful they are, and then analyze context-free, grammars, and see what's the,

192
00:25:13.660 --> 00:25:15.490
Francisco.Ortin@cit.ie: particular,

193
00:25:15.620 --> 00:25:24.270
Francisco.Ortin@cit.ie: feature that makes context-free grammar to be more expressive than regular languages. And these two, they're highly, highly expensive, so we're not going to deal with that, okay?

194
00:25:24.770 --> 00:25:32.860
Francisco.Ortin@cit.ie: One final thing to be said about this, I know it's pretty theoretical, okay, so I don't want to bother you much with this, is that

195
00:25:32.930 --> 00:25:49.810
Francisco.Ortin@cit.ie: the language you're going to implement is type 0, so it's Turing complete. C minus minus, the one in the labs, is Turing Complete. And we're using lexin and parsing from just this type 2 level. So how can we possibly do that if the language is type 2, type 0, sorry.

196
00:25:50.180 --> 00:25:54.210
Francisco.Ortin@cit.ie: So it's because we have other phases, like semantic analysis.

197
00:25:54.290 --> 00:25:58.310
Francisco.Ortin@cit.ie: And code generation that provides you with more features

198
00:25:58.320 --> 00:26:16.310
Francisco.Ortin@cit.ie: to control, or to check that the input is correct, all right? And that's why, using extra code, we keep doing these linear complexity algorithms for lexers and parsers, while providing Type Zero,

199
00:26:16.390 --> 00:26:27.929
Francisco.Ortin@cit.ie: language, which is C minus minus, okay? So somehow we're trading off between complexity, or expressiveness, and efficiency, or rental performance, all right?

200
00:26:28.510 --> 00:26:29.380
Francisco.Ortin@cit.ie: So…

201
00:26:29.470 --> 00:26:40.119
Francisco.Ortin@cit.ie: That's a very theoretical slide, but somehow motivates that the use of context-free grammars and regular expressions are so, so widespread in programming languages.

202
00:26:40.200 --> 00:26:57.680
Francisco.Ortin@cit.ie: Even as a programmer. As a programmer, you may have used regular expressions many times. Not that common context-free grammars, but they're more powerful, so it's worth learning about them. Okay, so let's try to remember, what a regular language is, a dive 3 programming language.

203
00:26:57.760 --> 00:27:03.039
Francisco.Ortin@cit.ie: And then, just, you know, practice a little with some activities I'm gonna ask you to do here.

204
00:27:03.300 --> 00:27:07.600
Francisco.Ortin@cit.ie: And then just going directly to context-free grammars, right?

205
00:27:08.700 --> 00:27:20.280
Francisco.Ortin@cit.ie: So, as I told you, patterns sometimes are represented or specified with regular languages, okay? They are so common. So, there are actually real languages that are still specified with regular languages.

206
00:27:20.330 --> 00:27:35.299
Francisco.Ortin@cit.ie: However, the Antler tool we're going to use, makes Lexer and parser specification, highly connected, so they, this, this tool, they, induces, context-free grammars for both approaches, lexin and parsing, okay?

207
00:27:35.820 --> 00:27:38.590
Francisco.Ortin@cit.ie: Okay, so let's remember what a regular language is.

208
00:27:38.860 --> 00:27:50.979
Francisco.Ortin@cit.ie: First is always described over an alphabet, okay? An alphabet is the input. So, in all my slides, the input I mentioned are

209
00:27:51.180 --> 00:28:08.680
Francisco.Ortin@cit.ie: for lexical analysis are characters, okay? I told you it could be binary information, or even some… somehow visual information. Whatever I'm going to explain here is valid for both case scenarios, but I'm just going to concentrate myself, explaining this into characters. So sigma is the…

210
00:28:09.540 --> 00:28:17.470
Francisco.Ortin@cit.ie: the elements of that set, and in this case, you may think as the ASCII table, so that's a sequence of characters that could be in the input.

211
00:28:17.700 --> 00:28:18.890
Francisco.Ortin@cit.ie: Okay?

212
00:28:19.070 --> 00:28:23.660
Francisco.Ortin@cit.ie: So, first recursive definition of a regular language is this one.

213
00:28:24.090 --> 00:28:39.409
Francisco.Ortin@cit.ie: the empty language. So, no input or string is accepted. In this… in this, case scenario, input and string, there are synonyms, okay? So sometimes if I say string, I mean input, okay? It's more formal string, but input is more,

214
00:28:39.590 --> 00:28:41.280
Francisco.Ortin@cit.ie: software engineering, I think.

215
00:28:41.640 --> 00:28:44.990
Francisco.Ortin@cit.ie: So the ampit language means nothing is recognized.

216
00:28:45.150 --> 00:28:45.950
Francisco.Ortin@cit.ie: Alright?

217
00:28:46.340 --> 00:28:53.670
Francisco.Ortin@cit.ie: Then, is just one character is recognized, A character, for instance, just the A letter, you may write it like this.

218
00:28:53.880 --> 00:28:55.079
Francisco.Ortin@cit.ie: Or like this.

219
00:28:55.370 --> 00:29:04.290
Francisco.Ortin@cit.ie: Okay? And obviously, A must be included in the alphabet, in the vocabulary, okay? It must be a valid character in Sigma.

220
00:29:04.690 --> 00:29:14.070
Francisco.Ortin@cit.ie: All right? There's an extra special character, a very important one, that is called epsilon. And epsilon is the anti-string.

221
00:29:14.500 --> 00:29:15.280
Francisco.Ortin@cit.ie: Okay?

222
00:29:15.880 --> 00:29:33.059
Francisco.Ortin@cit.ie: Okay, this is a very important character, because it's widely used. It's used a lot, okay? If I'm telling you that my language is just one character, like this one, A, it means that you can only write a letter, and that's it. That's the only program. I know it's stupid, but that's the way it is.

223
00:29:33.480 --> 00:29:38.570
Francisco.Ortin@cit.ie: Same way, if I'm asking you,

224
00:29:39.750 --> 00:29:46.150
Francisco.Ortin@cit.ie: epsilon, okay, as the only character that could be written, it means something different. It means that

225
00:29:46.520 --> 00:29:55.330
Francisco.Ortin@cit.ie: can I pass to my compiler an empty file? Is that an error, or is that okay? Okay, do you know what's… you know, it's a big difference.

226
00:29:55.440 --> 00:30:07.000
Francisco.Ortin@cit.ie: All right? So, some languages like Python, they allow you to have an empty file, okay? It's like running nothing. Doesn't… doesn't work, okay? Sorry, it does work, but it does… it does nothing, okay?

227
00:30:07.130 --> 00:30:16.270
Francisco.Ortin@cit.ie: But, for instance, C minus minus doesn't allow you to do that. You may at least have a main function, alright? So, be careful with those things, because they matter.

228
00:30:16.720 --> 00:30:21.809
Francisco.Ortin@cit.ie: Alright? And then, once you know that this is no input, and this is just one input.

229
00:30:22.040 --> 00:30:26.320
Francisco.Ortin@cit.ie: We define three recursive operators, which are

230
00:30:26.540 --> 00:30:32.830
Francisco.Ortin@cit.ie: union, okay? So if A and B are any regular language, it could be a letter or nothing.

231
00:30:32.960 --> 00:30:38.739
Francisco.Ortin@cit.ie: Then you may write union like this. We're gonna always use it like this. It's probably, always,

232
00:30:38.830 --> 00:30:55.479
Francisco.Ortin@cit.ie: You've seen regular expressions like this, using the pipe character. It means A or B, okay? So they could not be both at the same time, it could be one or the other one, okay? If you write one after the other one, it means concatenation. So if you write uppercase A,

233
00:30:56.690 --> 00:31:12.119
Francisco.Ortin@cit.ie: If you, sorry, if you write uppercase A and then uppercase B, it means that the program must have this character and next one this one, okay? So this program has two characters. This regular expression is recognizing two characters, okay?

234
00:31:12.420 --> 00:31:19.350
Francisco.Ortin@cit.ie: And finally, you have… and finally you have this, which is, probably empty…

235
00:31:19.570 --> 00:31:25.360
Francisco.Ortin@cit.ie: repetition of A's. So this pattern here allows you to have epsilon.

236
00:31:26.370 --> 00:31:45.560
Francisco.Ortin@cit.ie: which is nothing, so the empty file is correct, then one A, then two A's, three A's, and so on, all right? So this is the pattern for repetition, clean star. And there's no other operators. So if you've… you've seen PLAS, or there are many extensions, but the,

237
00:31:45.680 --> 00:32:02.379
Francisco.Ortin@cit.ie: canonical description of regular language is this one. Oops. So, obviously, with these, three operators, you may have any other… on any other operator, but that's, you don't need that. So the, all the expressiveness could be achieved with all the three, operators.

238
00:32:02.380 --> 00:32:07.660
Francisco.Ortin@cit.ie: So, but saying nothing in A, do we mean no withstand it in object-oriented programming.

239
00:32:07.900 --> 00:32:11.100
Francisco.Ortin@cit.ie: But say nothing, here?

240
00:32:11.330 --> 00:32:15.620
Francisco.Ortin@cit.ie: means that no program is valid. And saying nothing here.

241
00:32:16.040 --> 00:32:21.970
Francisco.Ortin@cit.ie: It means that if you pass this file to a compiler, it generates no error.

242
00:32:22.580 --> 00:32:27.539
Francisco.Ortin@cit.ie: Okay, so if this is called untitled.py, you may run it, and that's not an error.

243
00:32:27.740 --> 00:32:42.660
Francisco.Ortin@cit.ie: Okay? That's what I meant. Is that clear? Lilith? Yes, thank you. Great. So, regular expressions, formalized regular languages. So it's examples of regular expressions. So, this is, no program is allowed, okay?

244
00:32:43.320 --> 00:32:46.750
Francisco.Ortin@cit.ie: This is… only the empty program is allowed.

245
00:32:47.230 --> 00:32:55.329
Francisco.Ortin@cit.ie: And this means… 0 is allowed, epsilon is allowed, 1 is allowed.

246
00:32:55.530 --> 00:32:59.099
Francisco.Ortin@cit.ie: well, I'm gonna write it here, because otherwise… so epsilon…

247
00:32:59.340 --> 00:33:15.569
Francisco.Ortin@cit.ie: it's allowed, 0 is allowed, 1 is allowed, they may have 0 n times, and then 1 and 0, like this, you know, any possible repetition, including epsilon, including empty sequence of 0 and 1.

248
00:33:15.880 --> 00:33:17.140
Francisco.Ortin@cit.ie: Okay, thank you.

249
00:33:17.500 --> 00:33:20.340
Francisco.Ortin@cit.ie: Great, so let's move forward.

250
00:33:20.890 --> 00:33:30.689
Francisco.Ortin@cit.ie: Okay, so we're gonna practice a little with this, okay? And it's interesting because then you're gonna see how context-free grammar are more powerful and expressive that.

251
00:33:30.910 --> 00:33:40.960
Francisco.Ortin@cit.ie: regular expressions. And this… this way of practicing is always, beneficial, okay? Then you're gonna… when you go to Antler and start writing your grammars.

252
00:33:41.240 --> 00:33:50.140
Francisco.Ortin@cit.ie: is more complicated than you think. So, just doing these activities here, many times they seem to be very stupid, but they're…

253
00:33:50.250 --> 00:33:57.909
Francisco.Ortin@cit.ie: No matter what, beneficial, because somehow they're giving you some skills that, in the end, you will need for the labs, okay?

254
00:33:58.190 --> 00:34:07.620
Francisco.Ortin@cit.ie: So, I've just mentioned that regular expressions are a mechanism for describing regular languages, okay? So you may describe it with that notation.

255
00:34:07.790 --> 00:34:19.730
Francisco.Ortin@cit.ie: Okay, there's another notation in mathematics you used in high school that is called setbiller notation, that is another way to describe sets, okay? It's widely used in mathematics, and

256
00:34:20.239 --> 00:34:35.800
Francisco.Ortin@cit.ie: those sets are languages, okay? So if I'm describing regular language, I can use, regular expressions or setbid notation. So what I'm gonna do here is use setbindler notation to describe regular languages.

257
00:34:35.860 --> 00:34:44.260
Francisco.Ortin@cit.ie: And then you have to tell me how to describe them using regular expressions, which is another notation different to this one, right? So it's a way of practicing, nothing more.

258
00:34:44.630 --> 00:34:50.260
Francisco.Ortin@cit.ie: Okay? So using cell video notation, this is, that the NT program is allowed.

259
00:34:50.420 --> 00:35:00.979
Francisco.Ortin@cit.ie: And look at this. Here, I'm not using the previous three operators. I'm using something different here. I'm using exponential. So here, A to the N, meaning that N

260
00:35:01.590 --> 00:35:09.950
Francisco.Ortin@cit.ie: is at least 1, it means that A is a valid input, but it must be A, epsilon is not allowed, then AA

261
00:35:10.280 --> 00:35:13.740
Francisco.Ortin@cit.ie: and AAA, and so on and so forth. Okay, do you understand that?

262
00:35:13.960 --> 00:35:15.899
Francisco.Ortin@cit.ie: And this one here is telling you that

263
00:35:16.260 --> 00:35:19.899
Francisco.Ortin@cit.ie: A repeated n times, and N could be 0,

264
00:35:20.500 --> 00:35:30.389
Francisco.Ortin@cit.ie: followed by B repeated M times, and M could be 0. Or… B repeated n times.

265
00:35:31.320 --> 00:35:37.509
Francisco.Ortin@cit.ie: followed by A repeated M times, that's the language I want you to describe with regular expression. Is that clear?

266
00:35:41.410 --> 00:35:51.689
Francisco.Ortin@cit.ie: There's a question about… Tom is asking… sorry, Professor Ting, why… why this one here includes epsilon, okay? Because the definition of plane star

267
00:35:52.040 --> 00:35:56.760
Francisco.Ortin@cit.ie: Okay? Includes zero in its repetition.

268
00:35:57.010 --> 00:36:01.549
Francisco.Ortin@cit.ie: So, it's this clean star, this asterisk, whatever you use in it.

269
00:36:02.040 --> 00:36:11.340
Francisco.Ortin@cit.ie: it recognizes, epsilon. So it's… the correct answer here is by definition, because that operator works like that.

270
00:36:11.610 --> 00:36:16.260
Francisco.Ortin@cit.ie: All right, so every time you see the clean asterisk character, or the clean

271
00:36:16.800 --> 00:36:26.349
Francisco.Ortin@cit.ie: star, it means that it's any repetition of, what it's been applied to, including nothing, including epsilon, okay?

272
00:36:27.270 --> 00:36:28.200
Francisco.Ortin@cit.ie: Thank you.

273
00:36:28.900 --> 00:36:31.730
Francisco.Ortin@cit.ie: Right, so let's start with this activity here.

274
00:36:32.350 --> 00:36:33.580
Francisco.Ortin@cit.ie: So, first.

275
00:36:33.780 --> 00:36:39.740
Francisco.Ortin@cit.ie: What's the regular expression for epsilon? Well, I'm gonna write it here, because I'm always writing epsilon that way.

276
00:36:39.890 --> 00:36:47.050
Francisco.Ortin@cit.ie: So the first one is very simple. The regular expression is just epsilon. So this is for the first case scenario, okay?

277
00:36:47.370 --> 00:36:58.660
Francisco.Ortin@cit.ie: What about the second one? I want you to think about it and write it in the chat. You have to write a regular language, a regular expression, sorry, to describe this regular language, which is

278
00:36:58.890 --> 00:37:08.649
Francisco.Ortin@cit.ie: If you want me, I can write you examples, okay? One example is A, another one is AA, and another one is AAA.

279
00:37:08.730 --> 00:37:22.099
Francisco.Ortin@cit.ie: And you can infer the rest. So here in black, I want you to tell me what's the regular language that… with a regular expression. And remember, you may use this for letters.

280
00:37:22.270 --> 00:37:34.240
Francisco.Ortin@cit.ie: Epsilon is written in, lowercase Greek letter, and then you may use yes concatenation, which is writing nothing, the clean star for repetition, and OR is with this pipe symbol.

281
00:37:34.550 --> 00:37:37.590
Francisco.Ortin@cit.ie: Right? So those are the only three operators you've had.

282
00:37:38.550 --> 00:37:48.190
Francisco.Ortin@cit.ie: So what do you think? Very good, Rattle. Very, very good. So some people write, in other classes something like this, okay? Sorry, let's…

283
00:37:48.450 --> 00:37:50.499
Francisco.Ortin@cit.ie: Something like this. A+.

284
00:37:50.660 --> 00:38:02.319
Francisco.Ortin@cit.ie: And this is an operator that sometimes you may have, but it's not a canonical one. So, in other words, I didn't describe it in the previous slide. So, I must use a star.

285
00:38:02.570 --> 00:38:10.040
Francisco.Ortin@cit.ie: But hey, as Lilith said, this includes epsilon, so I need to first, they say, mandatory, start with an A.

286
00:38:10.220 --> 00:38:13.809
Francisco.Ortin@cit.ie: So I'm saying A, followed by any repetition of A,

287
00:38:14.160 --> 00:38:19.689
Francisco.Ortin@cit.ie: Including zero, including nothing, and that's why I have here this mandatory. So, very good, Ronald.

288
00:38:20.000 --> 00:38:25.009
Francisco.Ortin@cit.ie: Okay, thank you very much. Let's go to number 3. What about this one?

289
00:38:25.440 --> 00:38:29.440
Francisco.Ortin@cit.ie: Any repetitions of A, followed by any repetitions of B,

290
00:38:29.610 --> 00:38:34.940
Francisco.Ortin@cit.ie: or any repetitions of B, followed by any repetitions of, A.

291
00:38:36.610 --> 00:38:42.390
Francisco.Ortin@cit.ie: Try to do it always as simple as possible. So here we have A or B, Herb.

292
00:38:44.610 --> 00:38:51.009
Francisco.Ortin@cit.ie: Very good. Very good. So, we have… if you take a look at the chat, we have two proposals. Thank you very much for all.

293
00:38:51.150 --> 00:38:53.350
Francisco.Ortin@cit.ie: So…

294
00:38:53.510 --> 00:39:01.990
Francisco.Ortin@cit.ie: The first one, I'm gonna write here, so if someone's watching the video. The first one is a star…

295
00:39:02.970 --> 00:39:04.560
Francisco.Ortin@cit.ie: B is star.

296
00:39:04.760 --> 00:39:10.240
Francisco.Ortin@cit.ie: Or… B star, A star, parentheses.

297
00:39:10.610 --> 00:39:15.340
Francisco.Ortin@cit.ie: And the second one is… A B.

298
00:39:17.430 --> 00:39:27.280
Francisco.Ortin@cit.ie: Star is star… Or… B star, A star. This is a very interesting answer, very good.

299
00:39:30.890 --> 00:39:40.920
Francisco.Ortin@cit.ie: Great. So what's the difference between these two? Okay, if you analyze, the first one uses here those parentheses, which are doing nothing, because there's nothing outside.

300
00:39:41.000 --> 00:39:55.810
Francisco.Ortin@cit.ie: So these two parentheses are actually not required, so they're… well, by the way, both solutions are perfect, both solutions are correct, okay? But I'm just gonna show you the difference so that you're able to tell something very important you need in the labs. So.

301
00:39:56.300 --> 00:40:04.169
Francisco.Ortin@cit.ie: Both are correct answers, but hey, let's go back to the first one. This is not necessary, so I'm gonna delete it.

302
00:40:05.970 --> 00:40:13.789
Francisco.Ortin@cit.ie: This is not necessary either. So the difference between these two is this, parenthesis.

303
00:40:14.620 --> 00:40:24.220
Francisco.Ortin@cit.ie: Okay? Do I need the parentheses? Obviously, we don't, we don't need it. We know we don't need it, because I just say that. And the reason is because this operator here.

304
00:40:24.300 --> 00:40:34.849
Francisco.Ortin@cit.ie: It's the one with the lowest precedence, and this is very important in PLE. You're gonna speak… we're gonna, work with this a lot, a lot, all right?

305
00:40:35.450 --> 00:40:50.100
Francisco.Ortin@cit.ie: It's the one with the lowest precedence. It's the one that is evaluated last. So this repetition goes first and repeats B, this repeats A, this repeats B, this repeats A. So that's why you don't need those parentheses here below. Those are not required.

306
00:40:50.280 --> 00:41:09.159
Francisco.Ortin@cit.ie: You may use them if, for you, this is more readable, it's okay, but they're not required. And this is very important because, we're going to make grammars much more complicated, and writing, parentheses is something that, well, makes… when the production is, is pretty long, it makes,

307
00:41:09.240 --> 00:41:16.390
Francisco.Ortin@cit.ie: transactions not to be very readable, okay? Very, very good. Does the sentence matter here? Can we just say A, B?

308
00:41:16.570 --> 00:41:20.050
Francisco.Ortin@cit.ie: So, if you have… if you have A star.

309
00:41:20.420 --> 00:41:32.400
Francisco.Ortin@cit.ie: Very good question. There's another question here. Can we have this? Well, if you have this, then you can only start repeating A, AA, and then repeat B.

310
00:41:33.450 --> 00:41:36.040
Francisco.Ortin@cit.ie: Okay? But you cannot go back.

311
00:41:36.180 --> 00:41:38.330
Francisco.Ortin@cit.ie: and try to repeat A again.

312
00:41:38.460 --> 00:41:49.329
Francisco.Ortin@cit.ie: So, actually, this is not a correct answer, because this is supposed to be allowed in the specification of the language. You see that? Very good, very good.

313
00:41:49.500 --> 00:41:55.610
Francisco.Ortin@cit.ie: Great, great. It's always, always the brain is trying an error, and then,

314
00:41:55.740 --> 00:42:13.800
Francisco.Ortin@cit.ie: sometimes it's even better do it wrong, or having something that is, okay, is this correct? Once you know why it's not correct, then your brain is kind of understanding that, remembering that, and when you go further and you do something more complicated.

315
00:42:13.970 --> 00:42:23.040
Francisco.Ortin@cit.ie: you don't rethink about it, so it's like you're getting more… higher abstraction. So this is always good trying to do things. That's why I'm using activities here, otherwise just…

316
00:42:23.410 --> 00:42:36.510
Francisco.Ortin@cit.ie: You know, so, practice is a very… it's so important. Very good. And what about this one here? This is another that, I just skipped. So let's analyze that with a new slide here.

317
00:42:37.340 --> 00:42:55.499
Francisco.Ortin@cit.ie: So this, again, I'm going to use blue for showing you examples. So for this one here, you have this repeated n times, so let's have 3 times here, okay? And then it's closing the same number of times, N. Do you see that N there? So it's going to be like this, 3 and 3.

318
00:42:55.790 --> 00:43:02.650
Francisco.Ortin@cit.ie: And then in the middle, you may have any A and B repeated, okay? And M and N, they're not the same, they're different.

319
00:43:02.820 --> 00:43:07.150
Francisco.Ortin@cit.ie: So here, we may have ABA, for instance.

320
00:43:07.380 --> 00:43:14.620
Francisco.Ortin@cit.ie: Okay? We may have just one here, and nothing in the middle, because epsilon is included, since M includes 0.

321
00:43:15.050 --> 00:43:22.329
Francisco.Ortin@cit.ie: And we may have no, square brackets, and then AAB, for instance. All right? You understand that?

322
00:43:22.960 --> 00:43:28.949
Francisco.Ortin@cit.ie: So now the question is, Are you able to write a regular expression for that language?

323
00:43:33.430 --> 00:43:49.299
Francisco.Ortin@cit.ie: Okay, so the idea is, let's try it. Let's try it. Very good, by the way. I like your answers. Okay, so very good. So let's try it. First, we have to repeat square brackets, and epsilon is included, so the only way we can do that with the regular expression is this way, okay? Great.

324
00:43:49.460 --> 00:43:57.080
Francisco.Ortin@cit.ie: Then we have any repetition of AB, and 0 is included, so epsilon is included, so the only option is this one. So far, so good.

325
00:43:58.160 --> 00:44:02.560
Francisco.Ortin@cit.ie: And then we have, okay, any number of closing… of closing square brackets.

326
00:44:04.370 --> 00:44:05.270
Francisco.Ortin@cit.ie: So

327
00:44:05.440 --> 00:44:18.030
Francisco.Ortin@cit.ie: So, if you analyze this regular expression here, you say, okay, all the programs here in Cisco are actually recognized with a regular expression below, and say, okay, you're totally right, that's totally correct, but

328
00:44:18.280 --> 00:44:30.710
Francisco.Ortin@cit.ie: Something very important in language description, language specification, is that you must only recognize the programs that should be recognized, okay? So if you're recognizing something that is wrong, then your language is wrong.

329
00:44:30.710 --> 00:44:38.680
Francisco.Ortin@cit.ie: Because it's like you have a compiler that, you show no errors, and then the program is erroneous. So you must…

330
00:44:38.680 --> 00:44:46.190
Francisco.Ortin@cit.ie: identify what should be identified here, but also forbid what should be forbidden. So here, if you have this input.

331
00:44:47.420 --> 00:44:55.700
Francisco.Ortin@cit.ie: like this one, this regular expression on black accepts this input, and it shouldn't be affected. And that's why this is wrong.

332
00:44:55.850 --> 00:44:56.730
Francisco.Ortin@cit.ie: All right?

333
00:44:58.050 --> 00:45:14.299
Francisco.Ortin@cit.ie: So, after thinking about it, what you're looking for is, okay, I want this repetition to be exactly the way as this one, which is what this N thing is doing here. This N is making this repetition the same as opening and close square brackets.

334
00:45:14.400 --> 00:45:25.959
Francisco.Ortin@cit.ie: And then you realize, okay, okay, after some time, you say, there's no answer, because regular expressions, they don't allow you to do that. In other words, this is not

335
00:45:25.960 --> 00:45:38.570
Francisco.Ortin@cit.ie: a regular language. This is a context-free language, so it's impossible you're able to recognize that without regular expressions, because it's like you're trying to say something in a language that that language doesn't provide you with.

336
00:45:38.640 --> 00:45:39.450
Francisco.Ortin@cit.ie: All right?

337
00:45:39.720 --> 00:45:46.869
Francisco.Ortin@cit.ie: So, this is something important. So, in this case, if you want to recognize this pattern, you cannot use regular expressions, okay?

338
00:45:47.400 --> 00:45:48.300
Francisco.Ortin@cit.ie: Very good.

339
00:45:51.340 --> 00:45:52.140
Dmitrijs Dubrovs: Sorry.

340
00:45:52.440 --> 00:45:55.889
Francisco.Ortin@cit.ie: Yes. But wasn't there in the regex.

341
00:45:56.010 --> 00:45:58.009
Dmitrijs Dubrovs: syntax that allows…

342
00:45:58.280 --> 00:46:06.249
Dmitrijs Dubrovs: Like, to have matching number of, of, like, you know, like, where you put the number.

343
00:46:07.410 --> 00:46:09.500
Francisco.Ortin@cit.ie: Here, in the building notation, here.

344
00:46:10.620 --> 00:46:18.260
Dmitrijs Dubrovs: Yeah, so… so we can actually state that there should be a matching number For those brackets.

345
00:46:18.260 --> 00:46:23.420
Francisco.Ortin@cit.ie: Yeah, exactly. This, ever since I used the same N and N here.

346
00:46:23.570 --> 00:46:28.879
Francisco.Ortin@cit.ie: And N must be the same, because it's the same… the same, let's say, variable, okay?

347
00:46:29.100 --> 00:46:30.580
Francisco.Ortin@cit.ie: It means that…

348
00:46:30.730 --> 00:46:40.509
Francisco.Ortin@cit.ie: every open… opening square bracket should be matched with a closing square bracket. If I change gear, M, and here I write H,

349
00:46:40.890 --> 00:46:45.199
Francisco.Ortin@cit.ie: And here, say, H is also… then this one is perfect.

350
00:46:45.480 --> 00:46:57.260
Francisco.Ortin@cit.ie: this regular expression, but I didn't. I make, that, as you said, all the square brackets should be, matched. All right? Yes, very good. Any other questions or clarifications?

351
00:46:58.460 --> 00:47:00.160
Francisco.Ortin@cit.ie: Great. Thank you very much, Ruel.

352
00:47:01.200 --> 00:47:08.350
Francisco.Ortin@cit.ie: So I was… Here. Okay, good. So, remember this, because it's gonna be used later.

353
00:47:09.380 --> 00:47:24.849
Francisco.Ortin@cit.ie: Okay, that's… that's it for regular expressions. Sometimes we need more express… expressiveness, and that's what most real languages do, so we need context-free grammars. And Ampler uses context-free grammars for both,

354
00:47:25.050 --> 00:47:27.470
Francisco.Ortin@cit.ie: Lexers and parsers, alright?

355
00:47:27.920 --> 00:47:36.840
Francisco.Ortin@cit.ie: So, context-free grammars are defined formally with a four-tuple, right? So you have the Where's that?

356
00:47:37.330 --> 00:47:43.260
Francisco.Ortin@cit.ie: non-terminal vocabulary, then the terminal vocabulary. This is the same as sigma in,

357
00:47:43.670 --> 00:47:48.660
Francisco.Ortin@cit.ie: regular expressions. Then, a set of productions, rules.

358
00:47:48.810 --> 00:47:56.149
Francisco.Ortin@cit.ie: And then just… starting symbol, okay? Let's start one after the other word and see what they actually mean.

359
00:47:56.970 --> 00:48:03.949
Francisco.Ortin@cit.ie: So VT is vocabulary… terminal vocabulary, sorry. It's a finite set of terminals.

360
00:48:04.310 --> 00:48:05.350
Francisco.Ortin@cit.ie: Well…

361
00:48:05.660 --> 00:48:16.309
Francisco.Ortin@cit.ie: this is the same as we had in, with Sigma in regular expression. So far, the… the terminal vocabulary, or the vocabulary of the

362
00:48:16.500 --> 00:48:22.289
Francisco.Ortin@cit.ie: input, if you wish, were characters. But hey, be careful, there's something super important here.

363
00:48:22.740 --> 00:48:30.610
Francisco.Ortin@cit.ie: Context-free grammars are going to be used for both Lexical and syntactical analysis.

364
00:48:30.870 --> 00:48:31.700
Francisco.Ortin@cit.ie: Alright?

365
00:48:31.890 --> 00:48:40.099
Francisco.Ortin@cit.ie: it means that the input for lexical analysis is gonna be… are gonna be characters, but hey, what's gonna be the input for

366
00:48:40.300 --> 00:48:42.370
Francisco.Ortin@cit.ie: syntax analysis, or Parson.

367
00:48:42.850 --> 00:48:46.129
Francisco.Ortin@cit.ie: It's not gonna be characters, right? It's gonna be tokens.

368
00:48:46.380 --> 00:48:52.340
Francisco.Ortin@cit.ie: So be careful with that. VT, or sigma, in these context-free grammars, they could be

369
00:48:52.660 --> 00:48:58.029
Francisco.Ortin@cit.ie: Characters for lexical analysis, or tokens for,

370
00:48:58.350 --> 00:49:06.589
Francisco.Ortin@cit.ie: syntax analysis, all right? So it could be characters as we have here, A and B, but there could be something like, I'm gonna go back, something like

371
00:49:06.590 --> 00:49:18.939
Francisco.Ortin@cit.ie: in constant repeating n times, followed by incremental read and while, all right? Be careful with that. So depending on what you're doing, lexical or syntax analysis, the input changes, so

372
00:49:19.190 --> 00:49:24.990
Francisco.Ortin@cit.ie: so does the… Sigma, description, alright?

373
00:49:25.540 --> 00:49:34.330
Francisco.Ortin@cit.ie: So, be careful with that, this is important. What about non-terminal vocabulary? Well, this is kind of hard to describe, because it's very abstract.

374
00:49:34.520 --> 00:49:42.629
Francisco.Ortin@cit.ie: So I'm gonna try to give you the intuition, which is the most important thing when you're learning, and sometimes hard when you're lecturing, okay?

375
00:49:42.750 --> 00:49:56.759
Francisco.Ortin@cit.ie: So the intuition of non-terminal vocabulary is, like, a group of terminals that they could be classified, like a similar type or something like that.

376
00:49:56.770 --> 00:50:03.570
Francisco.Ortin@cit.ie: Okay? So in a real language grammar, context-free grammar, you will have non-terminals like

377
00:50:03.990 --> 00:50:12.369
Francisco.Ortin@cit.ie: expression, because there are many things that could be composed as expressions. You may have sentence.

378
00:50:12.510 --> 00:50:16.750
Francisco.Ortin@cit.ie: You may have definition, and so on and so forth, okay?

379
00:50:17.020 --> 00:50:28.840
Francisco.Ortin@cit.ie: So that's… that's the non-terminal vocabulary. So it's like grouping different tokens and sequences of tokens so that they behave in a similar way, okay? So it's like a classification problem.

380
00:50:29.420 --> 00:50:37.689
Francisco.Ortin@cit.ie: And then S is very simple, it's just identifying one symbol from this one here, okay? So it's called the start symbol.

381
00:50:37.690 --> 00:50:50.669
Francisco.Ortin@cit.ie: is the one that is grouping all the non-terminals in a program. Most of the times, I'm going to use program for that, okay? Because a program is their starting symbol for a program.

382
00:50:50.920 --> 00:51:03.690
Francisco.Ortin@cit.ie: Many times, formally, with stupid grammars that makes no sense just for doing activities, it's just directly written as S, alright? Starts from start. And then P, which is probably the most important part.

383
00:51:03.850 --> 00:51:08.989
Francisco.Ortin@cit.ie: It's a finite set of productions, or rules, described the following way.

384
00:51:09.160 --> 00:51:16.949
Francisco.Ortin@cit.ie: You write one non-terminal on the left, this one must be non-terminal, this is mandatory, again, by definition.

385
00:51:17.410 --> 00:51:31.779
Francisco.Ortin@cit.ie: Okay? And here on the right, it may be any sequence of terminals and non-terminals. So it could be epsilon, it could be one character, it could be one token, or sequences of tokens and non-tokens, or terminals and non-terminals, okay?

386
00:51:32.120 --> 00:51:35.630
Francisco.Ortin@cit.ie: What is exactly what is explained here.

387
00:51:35.820 --> 00:51:36.630
Francisco.Ortin@cit.ie: Alright?

388
00:51:37.040 --> 00:51:43.620
Francisco.Ortin@cit.ie: Very good. So that's a formal description of context-free grammars. All right? Let's practice a little with that.

389
00:51:43.930 --> 00:51:55.860
Francisco.Ortin@cit.ie: First with some basic samples, and then just doing some activities, more interesting activities. Okay, so let's define a very super simple context-free graph, and in a very formal way.

390
00:51:56.500 --> 00:52:11.399
Francisco.Ortin@cit.ie: So, in this grammar, terminal, non-terminal, sorry, are S and E. This is a stupid grammar, okay, but it's very good for practicing. Then we have terminals that are gonna be A and B.

391
00:52:11.460 --> 00:52:22.800
Francisco.Ortin@cit.ie: Just notice that in all my slides, starting from today up to the end of the module, I'm always going to use lowercase letters for non-terminals.

392
00:52:22.990 --> 00:52:30.649
Francisco.Ortin@cit.ie: and uppercase letters for terminals. And this is the unflure notation. I'm always going to use this same notation, okay?

393
00:52:30.760 --> 00:52:41.450
Francisco.Ortin@cit.ie: Be careful, because many looks… many books, they use the opposite, okay? But I'm using this one because it's the unclar notation. Ever since we're going to use unflure or not, then…

394
00:52:41.690 --> 00:52:43.829
Francisco.Ortin@cit.ie: I'm trying to be coherent.

395
00:52:44.260 --> 00:52:53.710
Francisco.Ortin@cit.ie: Then S is the starting symbol, so out of these two, I'm taking this one as the starting symbol, and P is defined as this, okay?

396
00:52:54.140 --> 00:53:12.709
Francisco.Ortin@cit.ie: So there are actually four protections here. You can see that always on the left, there are just one non-terminal. It's just one symbol, and it's lowercase, so it's non-terminal. And on the right, you have a sequence of terminals and non-terminals, okay? Here is just one terminal, here there are two, and so on.

397
00:53:13.110 --> 00:53:18.080
Francisco.Ortin@cit.ie: So here, those are the four protractions. Okay, so this is describing a language.

398
00:53:18.790 --> 00:53:19.690
Francisco.Ortin@cit.ie: Okay.

399
00:53:19.840 --> 00:53:22.599
Francisco.Ortin@cit.ie: Let's see one definition, which is spring.

400
00:53:22.640 --> 00:53:41.609
Francisco.Ortin@cit.ie: String is a sequence of symbols, and they could be terminal and non-terminal. So, this is a string, it's just a starting non-terminal symbol and non-terminal. This is another string, a terminal. This is another string, terminal followed by non-terminal, and this is another string. So, it's just any sequence, including epsilon, of terminals and non-terminals.

401
00:53:41.980 --> 00:53:42.760
Francisco.Ortin@cit.ie: All right.

402
00:53:43.420 --> 00:53:44.180
Francisco.Ortin@cit.ie: Okay.

403
00:53:44.360 --> 00:53:48.380
Francisco.Ortin@cit.ie: If you take one string, Like this one here.

404
00:53:48.930 --> 00:53:50.010
Francisco.Ortin@cit.ie: Okay, right here.

405
00:53:52.090 --> 00:53:55.320
Francisco.Ortin@cit.ie: You take one string here, like this one, AE.

406
00:53:56.620 --> 00:54:04.300
Francisco.Ortin@cit.ie: AA. And you choose one production here that could be applied, like this second one here, number 2.

407
00:54:04.850 --> 00:54:10.730
Francisco.Ortin@cit.ie: You may take this string and rewrite it or convert it. This is… I'm applying production number 2.

408
00:54:11.080 --> 00:54:13.120
Francisco.Ortin@cit.ie: So that this E…

409
00:54:13.470 --> 00:54:26.150
Francisco.Ortin@cit.ie: this one here is going to be replaced with the right-hand side. So we take the left-hand side and rewrite it with the right-hand side. So this comes from the original string, and taking this

410
00:54:26.180 --> 00:54:38.880
Francisco.Ortin@cit.ie: non-terminal and replacing it with A. Okay, so this is the one, the original one, and this is the one replaced. So this here is what is called one-step derivation, okay?

411
00:54:39.120 --> 00:54:43.320
Francisco.Ortin@cit.ie: Is what here is, representing with this imply symbol.

412
00:54:43.920 --> 00:54:57.089
Francisco.Ortin@cit.ie: So, with a language, you may take the starting non-terminal symbol and keep applying the productions until you reach a sequence of terminal symbols, and that's why it is language recognition.

413
00:54:57.300 --> 00:55:10.390
Francisco.Ortin@cit.ie: You start with the starting non-terminal symbol, and then you… you end up with the input program, which is just a sequence of characters or a sequence of tokens, depending on if you're using lexical analysis or syntax analysis.

414
00:55:10.450 --> 00:55:26.410
Francisco.Ortin@cit.ie: And that's why it's called language recognition. That's why grammars are so important, because they allow you to, in a very compact way, formally describe what a context-free language is, okay? Which, by the way, remember, is more powerful than regular expressions.

415
00:55:26.480 --> 00:55:27.280
Francisco.Ortin@cit.ie: Okay?

416
00:55:27.820 --> 00:55:45.379
Francisco.Ortin@cit.ie: Okay, so here you have an example. You start with S, okay, which is the starting non-terminal symbol, and here you're applying one production, which is the one you're applying? Well, number one, this is the only one with S, so it's the only one I actually can apply. So I replace an S with the right-hand side, I have AE, you see that?

417
00:55:45.550 --> 00:56:01.269
Francisco.Ortin@cit.ie: then I'm taking second, third, fourth production and replacing E with epsilon. If I take this E and replace it with epsilon, it's just writing nothing, so it's like deleting the E. So these, two one-step derivations.

418
00:56:01.270 --> 00:56:12.139
Francisco.Ortin@cit.ie: are recognizing the input A program, just one program with an A character. Okay, is that clear? So this is an example of program recognition using these productions

419
00:56:12.240 --> 00:56:14.550
Francisco.Ortin@cit.ie: By performing one-step derivation.

420
00:56:15.760 --> 00:56:17.600
Rudolf Adamkovič: I have a question.

421
00:56:17.600 --> 00:56:18.560
Francisco.Ortin@cit.ie: Yes?

422
00:56:18.560 --> 00:56:21.190
Rudolf Adamkovič: So, if there are these, productions.

423
00:56:21.300 --> 00:56:24.919
Rudolf Adamkovič: If E, produces A, B, and epsilon.

424
00:56:24.920 --> 00:56:25.660
Francisco.Ortin@cit.ie: Yes, here.

425
00:56:25.660 --> 00:56:30.800
Rudolf Adamkovič: Then, is it… because it's a set, so there is no order in them, right?

426
00:56:31.490 --> 00:56:33.210
Rudolf Adamkovič: So, which one is picked?

427
00:56:33.820 --> 00:56:38.780
Francisco.Ortin@cit.ie: Very good, very good question, very good question. So, actually, it depends on the input.

428
00:56:39.140 --> 00:56:46.700
Francisco.Ortin@cit.ie: So, this is, this is, how this works is you have an input, and there's… there should be one smart

429
00:56:47.400 --> 00:56:57.240
Francisco.Ortin@cit.ie: let's say personal algorithm that is able to take the appropriate production? That's a super good question. And that's a very hard problem to be solved.

430
00:56:57.640 --> 00:57:00.649
Francisco.Ortin@cit.ie: Okay, and that's what exactly Anthru is gonna do for you.

431
00:57:01.090 --> 00:57:01.900
Francisco.Ortin@cit.ie: Okay?

432
00:57:02.260 --> 00:57:08.870
Rudolf Adamkovič: Yeah, well, I'm not sure I understand. So, if E is… E produces A, and E produces B, right, in that set.

433
00:57:08.870 --> 00:57:16.639
Francisco.Ortin@cit.ie: Yeah, let's write here one example, if you don't mind, okay? Yeah. So your question is, your question is, okay, here I have this following input.

434
00:57:17.140 --> 00:57:24.670
Francisco.Ortin@cit.ie: have, for instance, I'm going to write here in blue, and say A BA.

435
00:57:25.130 --> 00:57:27.570
Francisco.Ortin@cit.ie: Okay? Okay, so we start with S.

436
00:57:27.770 --> 00:57:41.369
Francisco.Ortin@cit.ie: And we have to derive S. This is very simple, because there's only one possibility, so this is going to be this no matter what. But then, where you're asking me is, okay, I may replace… I should replace E, but E has three different alternatives.

437
00:57:41.610 --> 00:57:42.540
Francisco.Ortin@cit.ie: Okay?

438
00:57:43.150 --> 00:57:46.120
Francisco.Ortin@cit.ie: So now, what should be done is.

439
00:57:46.490 --> 00:57:51.019
Francisco.Ortin@cit.ie: And this is a super important question, is, okay, to recognize this input.

440
00:57:51.230 --> 00:57:53.890
Francisco.Ortin@cit.ie: What's the production that must be selected?

441
00:57:54.300 --> 00:58:11.309
Francisco.Ortin@cit.ie: We need intelligence for that. We need someone to take responsibility. As a human, okay, you would say, okay, this is the first one is A, the second one is B, so obviously it's going to be number 3. So here, we take the production number 3, this is the first one, and we replace A with

442
00:58:11.490 --> 00:58:21.019
Francisco.Ortin@cit.ie: oh, sorry, this is not… this is not possible. Replace this one with B, then we're not able to recognize the remaining,

443
00:58:22.380 --> 00:58:25.990
Francisco.Ortin@cit.ie: A. So this is not a valid input program.

444
00:58:26.160 --> 00:58:27.070
Francisco.Ortin@cit.ie: Okay?

445
00:58:27.840 --> 00:58:44.909
Francisco.Ortin@cit.ie: So I'm… sorry, that's my mistake, so I'm gonna go back and re-question the problem, okay? Sorry. The example was not correct, sorry. So here, is it possible to recognize AB? So I have this, and then I have to select A. You may say, okay, it is the second one.

446
00:58:45.260 --> 00:58:47.719
Francisco.Ortin@cit.ie: The third one, or the fourth one? What do you think?

447
00:58:49.570 --> 00:58:58.310
Francisco.Ortin@cit.ie: What is the production that must be selected in order to recognize AB, if I've already recognized A, and I have to replace E with something?

448
00:59:01.000 --> 00:59:02.229
Rudolf Adamkovič: Yo, wait a minute.

449
00:59:03.750 --> 00:59:06.060
Francisco.Ortin@cit.ie: So this production here is the only one that is correct.

450
00:59:06.060 --> 00:59:12.329
Rudolf Adamkovič: Oh, wait a minute, S is the starting, yeah, I'm still trying to figure this out.

451
00:59:12.330 --> 00:59:21.949
Francisco.Ortin@cit.ie: you always start with S, and then keeping projections, you have to be able to recognize always the input… the input program, the input string.

452
00:59:22.960 --> 00:59:26.430
Francisco.Ortin@cit.ie: Okay? How? By selecting the appropriate productions.

453
00:59:27.580 --> 00:59:31.989
Francisco.Ortin@cit.ie: Okay? So it's like a problem, it's like an algorithm, it's like a Sudoku you have to solve.

454
00:59:35.160 --> 00:59:55.090
Francisco.Ortin@cit.ie: Okay, so here, if you apply 1 first, you replace S, you always start with S, and then you have AE here, AE, this one here on the left. Then I have to replace E, then I choose the third one here, and instead of E, I have AB. So here, A, this is correct, because the input and the last

455
00:59:55.140 --> 00:59:58.340
Francisco.Ortin@cit.ie: production I applied, they're the same.

456
00:59:58.460 --> 01:00:07.890
Francisco.Ortin@cit.ie: In the previous example I deleted, there was no solution because there's no sequence of production applications that are able to recognize the input.

457
01:00:08.580 --> 01:00:09.440
Francisco.Ortin@cit.ie: Alright?

458
01:00:09.870 --> 01:00:10.960
Rudolf Adamkovič: Gotcha.

459
01:00:10.960 --> 01:00:25.739
Francisco.Ortin@cit.ie: Gotcha. You know, if that's the first time you're seeing this, it's complicated, I know. Yeah. Okay, that's why I made first lecture, I try always to give you the basics of the… so that you're able to make your decision, okay, am I gonna enroll in this,

460
01:00:25.810 --> 01:00:32.389
Francisco.Ortin@cit.ie: module or not, okay? So that's the idea. Originally, this module was only for

461
01:00:32.630 --> 01:00:35.559
Francisco.Ortin@cit.ie: software architecture and Design Master.

462
01:00:35.890 --> 01:00:46.490
Francisco.Ortin@cit.ie: than artificial intelligence. So, it depends on the… depends on your knowledge or on your previous studies and skills. So, it's up to you to decide, but be careful, because

463
01:00:47.050 --> 01:00:56.359
Francisco.Ortin@cit.ie: is this is the first time, this module is going to be hard, okay? So the idea, this is not the first time, and just, like,

464
01:00:56.460 --> 01:01:09.709
Francisco.Ortin@cit.ie: revisiting concept you already know. But it's up to you, okay? So I'm not gonna… so try… don't try to, please don't make me feel bad, all right? So it's something just telling you about, it's up… the final decision is yours, okay?

465
01:01:10.080 --> 01:01:12.430
Rudolf Adamkovič: Yeah, well, I will definitely practice, right?

466
01:01:12.430 --> 01:01:13.319
Francisco.Ortin@cit.ie: Okay, that's right, yeah.

467
01:01:13.320 --> 01:01:15.549
Rudolf Adamkovič: Take my notes and do these derivations myself.

468
01:01:15.550 --> 01:01:18.660
Francisco.Ortin@cit.ie: Right, exactly, exactly, okay. Any other questions?

469
01:01:20.190 --> 01:01:27.940
Francisco.Ortin@cit.ie: Okay, great, so I move forward. So let me reveal this slide. One second, please.

470
01:01:28.680 --> 01:01:31.390
Francisco.Ortin@cit.ie: Oh, yeah, we didn't answer this question.

471
01:01:31.610 --> 01:01:39.109
Francisco.Ortin@cit.ie: What's the language generated by G? Can you represent it with a regular expression? Okay, what's the language generated by G?

472
01:01:39.240 --> 01:01:41.530
Francisco.Ortin@cit.ie: Can you say it in English?

473
01:01:41.770 --> 01:01:45.239
Francisco.Ortin@cit.ie: So, if you take a look at this language, can you describe in English what's

474
01:01:45.350 --> 01:01:48.640
Francisco.Ortin@cit.ie: What… what are… which are the inputs that are recognized?

475
01:01:49.180 --> 01:01:51.000
Francisco.Ortin@cit.ie: A and B are characters.

476
01:01:55.360 --> 01:02:01.390
Francisco.Ortin@cit.ie: So it could be just A, then… Well, I'm gonna write here.

477
01:02:02.790 --> 01:02:08.189
Francisco.Ortin@cit.ie: So it could be A, because A is mandatory, then goes E, so…

478
01:02:08.520 --> 01:02:20.209
Francisco.Ortin@cit.ie: since… since E could be nothing, just A is okay, then there could be AA… sorry, here, I have to admit this guy here, yes. And then AB. You see that?

479
01:02:20.390 --> 01:02:22.939
Francisco.Ortin@cit.ie: And I think there are no other solutions.

480
01:02:23.080 --> 01:02:29.490
Francisco.Ortin@cit.ie: Okay, no other input programs. So it could be in English, it could be A, followed by A or B, for instance.

481
01:02:30.040 --> 01:02:31.999
Francisco.Ortin@cit.ie: Okay, great, great, great.

482
01:02:32.180 --> 01:02:41.539
Francisco.Ortin@cit.ie: And do you think this is a regular language? Or, if you wish, are you able to find a regular expression to recognize this?

483
01:02:42.170 --> 01:02:46.219
Francisco.Ortin@cit.ie: If you're able to identify a rigorous patient to recognize this.

484
01:02:46.320 --> 01:03:02.139
Francisco.Ortin@cit.ie: it definitely is a regular language. Otherwise, who knows? It's, again, it could be or not. As a lecturer, I know the answer, of course, but you always have to practice. So, is there… yeah, we can… there are many different regular expressions. This is one.

485
01:03:02.300 --> 01:03:09.829
Francisco.Ortin@cit.ie: Has… I think Rural is writing, and another one that is simple, Simpler, sorry, is this one.

486
01:03:10.170 --> 01:03:10.940
Francisco.Ortin@cit.ie: All right.

487
01:03:11.260 --> 01:03:29.670
Francisco.Ortin@cit.ie: So yeah, this is definitely the one in the slide here, this context-free grammar is describing a regular language, because remember, regular languages are a subset of context-free, of context-free languages, okay? Very good, that's the idea. So just theoretical computer lines.

488
01:03:29.670 --> 01:03:35.100
Rudolf Adamkovič: a little question. The second regular expression that you wrote.

489
01:03:35.100 --> 01:03:36.420
Francisco.Ortin@cit.ie: Sorry, say that again, the second?

490
01:03:36.420 --> 01:03:42.379
Rudolf Adamkovič: Yeah, the second is A, but it cannot be just A, no? The second one.

491
01:03:42.880 --> 01:03:47.610
Francisco.Ortin@cit.ie: Here, with this regular expression, A is allowed, because it's just one option.

492
01:03:47.610 --> 01:03:50.070
Rudolf Adamkovič: Yeah, but the one underneath, I mean.

493
01:03:50.070 --> 01:03:58.610
Francisco.Ortin@cit.ie: But here, then one underneath… oh, yeah, that's right, yeah, sorry, that's my mistake. Here, I forgot to write epsilon. You're totally right, my mistake.

494
01:03:58.610 --> 01:03:59.610
Rudolf Adamkovič: Super, thanks.

495
01:04:00.220 --> 01:04:07.029
Francisco.Ortin@cit.ie: Yeah, you're paying attention, I like that. Very good. Yes, we need epsilon for that. Great, great. Thank you.

496
01:04:07.890 --> 01:04:10.900
Francisco.Ortin@cit.ie: And, well, we've already answered these questions, great.

497
01:04:11.210 --> 01:04:12.250
Francisco.Ortin@cit.ie: So, yes.

498
01:04:14.310 --> 01:04:23.670
Francisco.Ortin@cit.ie: Okay, so I think we can have a break here. So I see you have 10 past, 7, and then we continue with this, okay? Thank you very much. See you in…

499
01:04:23.780 --> 01:04:24.339
Francisco.Ortin@cit.ie: I think it.

500
01:04:24.340 --> 01:04:40.279
Jaume Mesquida Lanas: Ortine, I have a question. When you write the epsilon, you write with this symbol, but if you are in the laptop, you write, like, user this symbol, or you put, like, epsilon and…

501
01:04:40.280 --> 01:04:43.800
Francisco.Ortin@cit.ie: Well, very good question. I was typing like this, but…

502
01:04:44.160 --> 01:04:58.440
Francisco.Ortin@cit.ie: Yeah, I mean, I understand that, yeah. Obviously, it depends on the… if you're thinking just implementation, okay, if you're in paper, if you're in paper, you can write a few ways. Well, I think Greek letters are better, because most of the people, they do that that way, okay? So it's a…

503
01:04:58.440 --> 01:05:04.300
Francisco.Ortin@cit.ie: You know, always trying to follow the same language. But if you're using a computer, well, a digital document.

504
01:05:04.450 --> 01:05:10.800
Francisco.Ortin@cit.ie: and you want it to be processed, it depends on the tool. So, in antler, we don't have epsilon

505
01:05:11.290 --> 01:05:30.009
Francisco.Ortin@cit.ie: neither… neither the… this grid later or epsilon like that. It's just writing nothing. We'll see that later. So it depends on the tool. Once we go to the tool, we will no longer be reading… writing, sorry, epsilon, and then it's going to be nothing. We're just writing nothing, okay? So we'll see that later. Very good question, John.

506
01:05:30.380 --> 01:05:31.199
Jaume Mesquida Lanas: Perfect, thank you.

507
01:05:31.200 --> 01:05:32.870
Francisco.Ortin@cit.ie: Okay, see you in 5 minutes. Okay, thank you.

508
01:05:41.000 --> 01:05:47.000
Francisco.Ortin@cit.ie: Okay, so let's continue with, writer's impressions and context-free grammars.

509
01:05:47.490 --> 01:05:48.280
Francisco.Ortin@cit.ie: So…

510
01:05:49.060 --> 01:06:00.550
Francisco.Ortin@cit.ie: The main difference between context-free grammars and regular expressions, and actually what makes context-free grammars to be more expressive than regular expressions, is recursion.

511
01:06:02.220 --> 01:06:09.950
Francisco.Ortin@cit.ie: So, if you're… If you have a protection like this one, Okay?

512
01:06:10.340 --> 01:06:13.349
Francisco.Ortin@cit.ie: Here we have only one e-simal.

513
01:06:14.860 --> 01:06:22.130
Francisco.Ortin@cit.ie: Allows you to do this… starting with the non-terminal E,

514
01:06:22.450 --> 01:06:25.510
Francisco.Ortin@cit.ie: allows you to have here A and B,

515
01:06:26.670 --> 01:06:31.270
Francisco.Ortin@cit.ie: Terminal, so this could be no, longer… derived.

516
01:06:31.580 --> 01:06:38.650
Francisco.Ortin@cit.ie: And then here, knee, okay? So you can see how E's use both left and right-hand side of the production.

517
01:06:38.760 --> 01:06:41.160
Francisco.Ortin@cit.ie: And obviously, this means that it's a curse.

518
01:06:42.010 --> 01:06:45.000
Francisco.Ortin@cit.ie: So, if we keep applying this production.

519
01:06:45.940 --> 01:06:48.990
Francisco.Ortin@cit.ie: I've applied it once, I'm gonna apply it twice.

520
01:06:49.300 --> 01:06:54.700
Francisco.Ortin@cit.ie: So here I have AA, E, Oops, BB, okay?

521
01:06:55.340 --> 01:06:57.789
Francisco.Ortin@cit.ie: Maybe, so here I'm replacing this E.

522
01:06:57.980 --> 01:07:01.599
Francisco.Ortin@cit.ie: Okay, with the right-hand side, which is AEB.

523
01:07:01.940 --> 01:07:06.289
Francisco.Ortin@cit.ie: Okay? If I apply… if you wouldn't… if you, rather…

524
01:07:06.490 --> 01:07:17.899
Francisco.Ortin@cit.ie: want me to write here the production that is applied. Here is one, here is one, and here I'm going to just apply the second one, okay? Which is replacing E with epsilon. So I'm going to write AA,

525
01:07:18.100 --> 01:07:19.130
Francisco.Ortin@cit.ie: BB.

526
01:07:19.680 --> 01:07:20.800
Francisco.Ortin@cit.ie: Okay, so…

527
01:07:21.110 --> 01:07:31.519
Francisco.Ortin@cit.ie: what this example… what's this recursion doing in this example? It's allowing you to have n repetitions of A

528
01:07:31.660 --> 01:07:34.010
Francisco.Ortin@cit.ie: Followed by N repetitions of B.

529
01:07:34.460 --> 01:07:38.660
Francisco.Ortin@cit.ie: Some of you asked me about the matching behavior of

530
01:07:39.290 --> 01:07:43.340
Francisco.Ortin@cit.ie: this character. Remember what? You remember in the previous activity?

531
01:07:43.500 --> 01:07:56.520
Francisco.Ortin@cit.ie: So this recursion is allowing you to do that, that if you remember, in regular expressions, we cannot do, because if we write this, then there are no the same repetitions, okay? So there are no, like, matching.

532
01:07:56.810 --> 01:08:05.430
Francisco.Ortin@cit.ie: Right? So recursion is the feature that allows context-free grammars to be more expressive than regular expressions.

533
01:08:05.570 --> 01:08:07.439
Francisco.Ortin@cit.ie: Okay? This is very, very important.

534
01:08:07.900 --> 01:08:12.169
Francisco.Ortin@cit.ie: So here, what's the language generated by G? Well, I think it's very easy, is…

535
01:08:12.300 --> 01:08:20.460
Francisco.Ortin@cit.ie: Any, including epsilon, any repetition of the same A's Followed by the same piece.

536
01:08:20.689 --> 01:08:26.190
Francisco.Ortin@cit.ie: All right? Is it possible to represent that language with regular expression? But actually, I've just said.

537
01:08:26.939 --> 01:08:34.299
Francisco.Ortin@cit.ie: It is not possible, because again, we don't have any way of making these two clean stars to have the same number of repetitions.

538
01:08:34.569 --> 01:08:44.609
Francisco.Ortin@cit.ie: As you can see here, with recursion, we can do that, okay? We can do more things, actually, because we may say, okay, if here I have two Bs instead of one, I may have

539
01:08:44.760 --> 01:08:47.190
Francisco.Ortin@cit.ie: a number of A's, and here the…

540
01:08:47.290 --> 01:08:51.719
Francisco.Ortin@cit.ie: double number of bees, okay? So, recursion is really, really powerful.

541
01:08:52.120 --> 01:09:05.910
Francisco.Ortin@cit.ie: Yeah, this is a very minimal one. Yeah, I like this, always these examples to understand the concept, and then practicing with more real case scenarios, so that you get the idea, you get skillful, and when you go to the lab.

542
01:09:07.029 --> 01:09:14.269
Francisco.Ortin@cit.ie: you don't start from scratch, okay? Because writing the grammar of a real language like, C minus minus, or…

543
01:09:14.479 --> 01:09:20.040
Francisco.Ortin@cit.ie: tiny language, but a Turing complete language. It's not easy, all right? So,

544
01:09:20.950 --> 01:09:38.869
Francisco.Ortin@cit.ie: If you take a look at one description, for instance, my description, you say, okay, this is very simple, I understand it perfectly. But if you try to do it yourself, it's not that simple, okay? So it's very similar when you start programming in one language, that you understand everything, but when you have to create it from scratch, it's kind of hard.

545
01:09:39.899 --> 01:09:40.859
Francisco.Ortin@cit.ie: Great.

546
01:09:41.330 --> 01:09:44.239
Francisco.Ortin@cit.ie: A common notation, for,

547
01:09:44.810 --> 01:09:47.490
Francisco.Ortin@cit.ie: Context-free grammars is B and F.

548
01:09:47.710 --> 01:09:53.399
Francisco.Ortin@cit.ie: That stands for Backus Normal Phone, and it's the one I've been using ever since I have

549
01:09:54.250 --> 01:09:57.169
Francisco.Ortin@cit.ie: Describing, what a context-free grammar is.

550
01:09:57.460 --> 01:10:10.829
Francisco.Ortin@cit.ie: So it's just writing always non-terminal on the left, then an arrow, and any repetition of terminals and non-terminals on the right, okay? You may use this OR, okay.

551
01:10:11.040 --> 01:10:29.359
Francisco.Ortin@cit.ie: for, not repeating this E implies, okay? This is very common, but this is also common as well in BNF, okay? Then we're gonna see an extension of this BNF. So right now, we're just with the canonical approach. It's the simplest way of representing context-free grammars.

552
01:10:29.660 --> 01:10:30.490
Francisco.Ortin@cit.ie: Alright?

553
01:10:30.920 --> 01:10:42.939
Francisco.Ortin@cit.ie: But please do not write this way, because here, if you write this way, many people may think that this is A followed by E, and then B or epsilon.

554
01:10:43.090 --> 01:11:02.899
Francisco.Ortin@cit.ie: If you were paying attention, one of the activities we have, there was one student that also introduced, already, sorry, introduced, the concept of these precedence. So actually, this below represents exactly the one as above, but it may be,

555
01:11:03.570 --> 01:11:10.439
Francisco.Ortin@cit.ie: not as readable as this one here. So here, we know for sure there are two productions. Here is kind of…

556
01:11:10.730 --> 01:11:20.110
Francisco.Ortin@cit.ie: is not the… as readable as above, okay? So be careful with that, particularly when you're in the lab trying to specify the productions, because they're not going to be that easy, okay?

557
01:11:20.310 --> 01:11:21.050
Francisco.Ortin@cit.ie: Yeah.

558
01:11:21.270 --> 01:11:29.389
Francisco.Ortin@cit.ie: So remember, I already told you, but just remember, always, I'm going to use the notation of terminals written with

559
01:11:29.720 --> 01:11:45.049
Francisco.Ortin@cit.ie: uppercase letters? Well, actually, what matters is the first letter, okay? But I'm always going to use all the characters uppercased, and non-terminals are going to be lowercased, okay? Remember, this is very important. So here, no, this is a token, this is not, all right?

560
01:11:45.580 --> 01:12:03.539
Francisco.Ortin@cit.ie: Right. Okay, so now we have to practice. It's time for practice. And what we have here is a very interesting activity that I keep simple, but at the same time is real. There are some patterns that are repeated again and again when you're describing a language, a real language.

561
01:12:03.640 --> 01:12:04.370
Francisco.Ortin@cit.ie: Okay?

562
01:12:04.750 --> 01:12:07.850
Francisco.Ortin@cit.ie: So I'm gonna… I'm gonna tell you how it goes.

563
01:12:08.410 --> 01:12:13.260
Francisco.Ortin@cit.ie: We have 3 different activities, okay? Three different languages to be specified.

564
01:12:13.650 --> 01:12:14.490
Francisco.Ortin@cit.ie: Okay?

565
01:12:15.000 --> 01:12:21.090
Francisco.Ortin@cit.ie: Then, to specify the language, I used two notations. The build… setbuilder notation.

566
01:12:21.910 --> 01:12:27.110
Francisco.Ortin@cit.ie: or just a sequence of examples, okay? I'll give you some examples.

567
01:12:28.710 --> 01:12:35.760
Francisco.Ortin@cit.ie: So what you have to do is always describe a language These patterns are…

568
01:12:35.990 --> 01:12:44.050
Francisco.Ortin@cit.ie: patterns of repetitions. Always describe a language that starts with list implies, and then you have to write here this one, and if you need more productions.

569
01:12:44.880 --> 01:12:48.800
Francisco.Ortin@cit.ie: No problem, okay? So for one language, you may need more productions.

570
01:12:49.550 --> 01:13:00.000
Francisco.Ortin@cit.ie: Remember, you have to recognize what is asked, and nothing else. This is very important. So be careful if you recognize something that shouldn't, that's… that's a mistake, that's an error.

571
01:13:00.330 --> 01:13:02.689
Francisco.Ortin@cit.ie: Okay, so here, for instance, this is…

572
01:13:03.230 --> 01:13:09.560
Francisco.Ortin@cit.ie: A character repeated at least once, okay? So the examples are A as an input.

573
01:13:09.760 --> 01:13:11.330
Francisco.Ortin@cit.ie: So this is one example.

574
01:13:12.210 --> 01:13:18.850
Francisco.Ortin@cit.ie: or AA, or AAA, okay? And so on and so forth. So there's no epsilon.

575
01:13:19.320 --> 01:13:20.110
Francisco.Ortin@cit.ie: Okay?

576
01:13:20.690 --> 01:13:26.569
Francisco.Ortin@cit.ie: So you have to think what to write here on the right-hand side of the production, so that you are able

577
01:13:26.680 --> 01:13:32.239
Francisco.Ortin@cit.ie: To understand this. And this is any repetition that is, you know, any language you know has repetitions.

578
01:13:32.390 --> 01:13:34.670
Francisco.Ortin@cit.ie: Okay? In many different places.

579
01:13:37.740 --> 01:13:47.259
Francisco.Ortin@cit.ie: So how do you write repetitions? I give you some time, and you write it in the chat, if you don't mind, okay? So you have to write list, then in this arrow, and then the wrong-hand side.

580
01:13:55.450 --> 01:14:07.569
Francisco.Ortin@cit.ie: If you're watching the video, it's always, it's always worth pausing the video, try to do it by yourself, and then continuing. Always practicing is good, okay?

581
01:14:08.140 --> 01:14:11.050
Francisco.Ortin@cit.ie: So the more you practice, the easier the lab is going to be.

582
01:14:15.510 --> 01:14:17.240
Francisco.Ortin@cit.ie: So, we have here…

583
01:14:18.140 --> 01:14:24.839
Francisco.Ortin@cit.ie: S is… so we… here, list is S, okay? So the start non-terminal symbol is list.

584
01:14:25.090 --> 01:14:33.959
Francisco.Ortin@cit.ie: And then, I don't understand… A, so you have something like A here?

585
01:14:36.720 --> 01:14:39.800
Francisco.Ortin@cit.ie: Sorry, I don't… Demetris, I don't understand your notation, sorry.

586
01:14:40.730 --> 01:14:42.850
Dmitrijs Dubrovs: Oh, I got it wrong, I got it wrong, sorry.

587
01:14:42.850 --> 01:14:49.029
Francisco.Ortin@cit.ie: No worries, no worries. It's always a matter of trying. So here we have another alternative. This is the

588
01:14:49.600 --> 01:15:04.839
Francisco.Ortin@cit.ie: is using S. Please do not use S if you don't mind. It's better to use a name, so this is a list or a repetition, just try to avoid it. I know the activity is very simple. Okay, so this works, actually. This is a very good solution, okay? So you may start…

589
01:15:06.000 --> 01:15:09.580
Francisco.Ortin@cit.ie: I'm gonna write examples here. You may start with list implies

590
01:15:10.560 --> 01:15:17.780
Francisco.Ortin@cit.ie: A, but you enter in an infinite loop. So there's something here we need to add, okay? Because you will always try to

591
01:15:18.160 --> 01:15:21.070
Francisco.Ortin@cit.ie: replace L, okay? Sorry.

592
01:15:21.790 --> 01:15:24.050
Francisco.Ortin@cit.ie: Sorry, sorry, don't go that fast, Francisco.

593
01:15:24.380 --> 01:15:28.360
Francisco.Ortin@cit.ie: Here, like this, okay? So you have to give something

594
01:15:29.450 --> 01:15:33.759
Francisco.Ortin@cit.ie: you have to stop it, you have to give another production. Exactly. You need to hear…

595
01:15:33.910 --> 01:15:50.859
Francisco.Ortin@cit.ie: A, not epsilon, just A, because epsilon is not allowed. Well, you may write epsilon here, but it doesn't make sense to write epsilon here, because epsilon, remember, is nothing. Okay, so very good. This is… this is, one solution, all right? So I'm gonna start here with L.

596
01:15:51.580 --> 01:15:55.859
Francisco.Ortin@cit.ie: L implies… A, so we have this one here, you see that?

597
01:15:56.290 --> 01:16:00.630
Francisco.Ortin@cit.ie: So, L implies… AL…

598
01:16:01.250 --> 01:16:08.450
Francisco.Ortin@cit.ie: I'm gonna change this one here, I'm gonna replace this L, so it's gonna be A A…

599
01:16:08.630 --> 01:16:11.430
Francisco.Ortin@cit.ie: Okay, here is by selecting…

600
01:16:11.670 --> 01:16:30.660
Francisco.Ortin@cit.ie: Production number 2, and production number 1, and number 1, so 2 A's are here, and three A's is… I choose the first one, so I have AL here. I'm gonna choose first one again, AAL, I'm gonna choose Epsilon… well, not Epsilon, sorry, second one.

601
01:16:30.780 --> 01:16:50.179
Francisco.Ortin@cit.ie: have AAA. So you can see, this is a demonstration that these three programs are recognized by this language. Here, you're using right recursion, because this list is on the right of the production. The activity is trying to make you work using both left and right recursion. So.

602
01:16:50.730 --> 01:17:00.019
Francisco.Ortin@cit.ie: If you want to do it with left recursion, is list A or A. That's it. Solution. Very good.

603
01:17:00.130 --> 01:17:01.260
Francisco.Ortin@cit.ie: Any questions?

604
01:17:02.350 --> 01:17:06.299
Francisco.Ortin@cit.ie: Do you want to propose another solution? Do you don't know if it's correct or not?

605
01:17:08.040 --> 01:17:13.120
Francisco.Ortin@cit.ie: Okay, dude, so we're gonna move to production number two. Sorry, language number two.

606
01:17:14.880 --> 01:17:19.610
Francisco.Ortin@cit.ie: So this one here was for language number 2. Let's go to language number…

607
01:17:23.060 --> 01:17:23.740
Francisco.Ortin@cit.ie: True.

608
01:17:24.430 --> 01:17:29.360
Francisco.Ortin@cit.ie: Okay, here you have… The same as above, but epsilon is included.

609
01:17:29.470 --> 01:17:32.619
Francisco.Ortin@cit.ie: So you have here epsilon, A,

610
01:17:32.780 --> 01:17:35.110
Francisco.Ortin@cit.ie: AA, and so on and so forth.

611
01:17:35.450 --> 01:17:37.419
Francisco.Ortin@cit.ie: And again, you have to tell me

612
01:17:37.760 --> 01:17:40.870
Francisco.Ortin@cit.ie: what to write here. List implies.

613
01:17:41.920 --> 01:17:43.400
Francisco.Ortin@cit.ie: Give you some time.

614
01:17:45.280 --> 01:17:47.359
Francisco.Ortin@cit.ie: Very good, we have a solution here.

615
01:17:48.350 --> 01:17:55.379
Francisco.Ortin@cit.ie: Very good. So we have A list, and here is the same as the previous one, but instead of A, since we have epsilon.

616
01:17:55.590 --> 01:17:57.360
Francisco.Ortin@cit.ie: Then we have here.

617
01:17:57.550 --> 01:17:58.300
Francisco.Ortin@cit.ie: Okay?

618
01:17:58.880 --> 01:18:06.870
Francisco.Ortin@cit.ie: And this is left recursive… sorry, right recursive. Left recursive is list, implies list A.

619
01:18:08.010 --> 01:18:09.490
Francisco.Ortin@cit.ie: or epsilon.

620
01:18:10.170 --> 01:18:13.780
Francisco.Ortin@cit.ie: You want me to derive here, I'm gonna do it? No worries.

621
01:18:14.080 --> 01:18:19.820
Francisco.Ortin@cit.ie: So this is gonna be green, so list implies… Epsilon…

622
01:18:21.040 --> 01:18:24.139
Francisco.Ortin@cit.ie: Production number two, and that makes this demonstration.

623
01:18:24.350 --> 01:18:28.960
Francisco.Ortin@cit.ie: then list implies production number one A list.

624
01:18:29.360 --> 01:18:37.969
Francisco.Ortin@cit.ie: And L is going to be replaced with product… used in production number 2 with epsilon, so we have A. A is the input, A is the output.

625
01:18:38.680 --> 01:18:42.689
Francisco.Ortin@cit.ie: And here we have, again, 1AL.

626
01:18:42.720 --> 01:19:00.119
Francisco.Ortin@cit.ie: We're gonna replace this underlined L, again, using one production number 1, sorry. And we have AAL, and using production number 2, we have here epsilon, so it's just two A's. So you can see how this is the same as this one here.

627
01:19:00.550 --> 01:19:02.509
Francisco.Ortin@cit.ie: Very good, good job, you're doing great.

628
01:19:02.710 --> 01:19:07.370
Francisco.Ortin@cit.ie: Any questions, or do we move to Language 3? Great, very good, Jama. Great.

629
01:19:08.070 --> 01:19:14.580
Francisco.Ortin@cit.ie: So let's go to language 3. This is more complicated, okay? Not saying difficult, but more complicated.

630
01:19:15.810 --> 01:19:20.309
Francisco.Ortin@cit.ie: So here, again, this means repetition.

631
01:19:20.930 --> 01:19:28.510
Francisco.Ortin@cit.ie: So here, language… I'm gonna write here, language 3… whoops, language for grammar 3.

632
01:19:30.830 --> 01:19:35.960
Francisco.Ortin@cit.ie: has at least one occurrence of A,

633
01:19:36.490 --> 01:19:41.920
Francisco.Ortin@cit.ie: But then comma A could be repeated zero or more times, okay?

634
01:19:42.130 --> 01:19:45.460
Francisco.Ortin@cit.ie: So one input is A. Oops.

635
01:19:46.660 --> 01:19:48.120
Francisco.Ortin@cit.ie: unable to say.

636
01:19:48.390 --> 01:19:53.810
Francisco.Ortin@cit.ie: Another one is A comma A. Comma should be included in the grammar, right?

637
01:19:56.200 --> 01:20:03.159
Francisco.Ortin@cit.ie: And so on and so forth. This is what is at least one item repeated n times.

638
01:20:03.260 --> 01:20:12.380
Francisco.Ortin@cit.ie: with comma-separated, powder, with a comma-separating powder. This is very common, for instance, when you have and…

639
01:20:12.700 --> 01:20:24.049
Francisco.Ortin@cit.ie: And what you describe here in C language must be at least one A, but could be A comma B, or A comma B, C, you know? This is so typical. Well, all the patterns we're doing are so typical.

640
01:20:24.480 --> 01:20:30.399
Francisco.Ortin@cit.ie: But I'm just trying to make it as simple as possible, all right? So this is one example I'm gonna delete here.

641
01:20:31.770 --> 01:20:36.840
Francisco.Ortin@cit.ie: To motivate your work, And I'm gonna write here again, this implies.

642
01:20:37.250 --> 01:20:42.000
Francisco.Ortin@cit.ie: So sometime for you guys, and you tell me what the solution is.

643
01:20:43.120 --> 01:20:44.280
Francisco.Ortin@cit.ie: And again.

644
01:20:44.630 --> 01:20:53.900
Francisco.Ortin@cit.ie: we recognize only what should be recognized, and try… always try to make it as simple as possible, the same as what you're doing when you're programming, okay? Try to not make things…

645
01:20:54.110 --> 01:20:57.140
Francisco.Ortin@cit.ie: Too complicated.

646
01:21:04.020 --> 01:21:06.600
Francisco.Ortin@cit.ie: Well, comma, you can just write comma directly.

647
01:21:09.220 --> 01:21:18.179
Francisco.Ortin@cit.ie: Well, there's a question. All the lectures are recursive. Well, if you want to repeat, and you're using context-free grammar, recursion is widely used, but sometimes you don't need recursion.

648
01:21:18.320 --> 01:21:24.060
Francisco.Ortin@cit.ie: For instance, if you're describing a class, you may have… you may have public or nothing.

649
01:21:24.770 --> 01:21:30.639
Francisco.Ortin@cit.ie: followed by class, and then an identifier. There, you don't need the recursion, so it depends.

650
01:21:30.810 --> 01:21:42.550
Francisco.Ortin@cit.ie: It depends, okay? It depends on the grammar, it depends on the problem, but recursions is something you may use, it's not you must use, alright? But if, let's say, if you look into.

651
01:21:42.840 --> 01:21:45.350
Dmitrijs Dubrovs: Any plus file, right?

652
01:21:45.830 --> 01:21:55.709
Dmitrijs Dubrovs: you have your constructor, your variables, and then, let's say, you create, some function methods, right? So…

653
01:21:56.270 --> 01:22:01.410
Dmitrijs Dubrovs: All the methods, they follow the same, lex, sir.

654
01:22:01.540 --> 01:22:07.340
Dmitrijs Dubrovs: So, meaning… It will check every time for that pattern for the method.

655
01:22:07.880 --> 01:22:11.910
Dmitrijs Dubrovs: So it has to be recursive, because you can add as many as you want.

656
01:22:12.190 --> 01:22:19.990
Dmitrijs Dubrovs: So it… because when we compile, right, from the first lecture, it will be all a single line.

657
01:22:22.040 --> 01:22:25.700
Francisco.Ortin@cit.ie: Yeah, well, if you're thinking in lines, Well, I'm turning…

658
01:22:25.700 --> 01:22:37.909
Dmitrijs Dubrovs: What I'm meaning, right? So, we will have some pattern, let's say, for a constructor, and we will describe that this pattern should be used only once, because…

659
01:22:38.260 --> 01:22:39.020
Dmitrijs Dubrovs: Oh.

660
01:22:39.130 --> 01:22:42.900
Dmitrijs Dubrovs: Well, it depends, again, on the language, but basically we have one constructed.

661
01:22:42.900 --> 01:22:44.150
Francisco.Ortin@cit.ie: Unless there's a…

662
01:22:44.150 --> 01:22:55.250
Dmitrijs Dubrovs: different variables in it, right? But for the lecturer that checks the method, it should be recursive, because it can have multiple methods inside one class.

663
01:22:56.440 --> 01:22:58.450
Francisco.Ortin@cit.ie: So it would check…

664
01:22:59.180 --> 01:23:00.950
Dmitrijs Dubrovs: The same thing all over again.

665
01:23:00.950 --> 01:23:18.939
Francisco.Ortin@cit.ie: Yeah, every time you need… you have more than one, you need repetition. Now, with this canonical approach, you… you must use recursion. So if you're using a tool that is using BNF notation, some tools are not very powerful, they're just based on BNF.

666
01:23:19.210 --> 01:23:26.739
Francisco.Ortin@cit.ie: You will have to use a lot of recursion, that's true. But… but, Anklar has extended BNF,

667
01:23:26.910 --> 01:23:29.859
Francisco.Ortin@cit.ie: And it gives you, the clean start operator.

668
01:23:30.200 --> 01:23:42.740
Francisco.Ortin@cit.ie: So many repetitions, you don't need to use recursion, because you have other options. But the canonical approach, if you only have the canonical approach, which is BNF, you must use recursion in all those cases you mentioned. Yeah, exactly, yes.

669
01:23:42.880 --> 01:23:43.700
Dmitrijs Dubrovs: Okay.

670
01:23:43.700 --> 01:23:47.940
Francisco.Ortin@cit.ie: We'll say that Antler is much, much more powerful, yes. Very good question.

671
01:23:48.460 --> 01:23:50.619
Francisco.Ortin@cit.ie: Okay, so, you're welcome.

672
01:23:51.270 --> 01:23:56.250
Francisco.Ortin@cit.ie: So we have A comma, list… Okay, comma.

673
01:23:57.730 --> 01:23:59.859
Francisco.Ortin@cit.ie: Okay, let's work this one. Thank you, Conor.

674
01:24:00.100 --> 01:24:01.739
Francisco.Ortin@cit.ie: So we have here list.

675
01:24:02.280 --> 01:24:05.300
Francisco.Ortin@cit.ie: A, and then another protection here, E.

676
01:24:06.140 --> 01:24:10.709
Francisco.Ortin@cit.ie: then E implies… Comma, A.

677
01:24:11.020 --> 01:24:15.600
Francisco.Ortin@cit.ie: E… And then A implies Absolutely.

678
01:24:16.020 --> 01:24:20.449
Francisco.Ortin@cit.ie: So we have here, list implies AE,

679
01:24:21.130 --> 01:24:26.330
Francisco.Ortin@cit.ie: So far, it's correct, because A is mandatory. Let's… let's analyze on these two.

680
01:24:26.740 --> 01:24:34.160
Francisco.Ortin@cit.ie: So if I have epsilon here, it's just 1A, which is correct, and if I'm replacing this one here, E,

681
01:24:34.540 --> 01:24:41.570
Francisco.Ortin@cit.ie: Then it's gonna be… A, and then comma A… E again.

682
01:24:42.310 --> 01:24:43.290
Francisco.Ortin@cit.ie: Okay?

683
01:24:43.390 --> 01:24:50.160
Francisco.Ortin@cit.ie: So, yeah, this is correct. It's more complicated than it could be.

684
01:24:50.490 --> 01:24:56.719
Francisco.Ortin@cit.ie: Okay, so there's a simpler solution, but it's correct. Very good color, right? So I'm going to try to…

685
01:24:56.830 --> 01:25:01.409
Francisco.Ortin@cit.ie: make it simpler here. So, another option could be list.

686
01:25:03.120 --> 01:25:15.109
Francisco.Ortin@cit.ie: implies. So we need, for sure, A, right? That's… that's what we learned here. And let's try to move this up. So it could be just one A. So let's write here an option.

687
01:25:15.580 --> 01:25:23.590
Francisco.Ortin@cit.ie: Right? And the option could be something like, A, if you put this together, like Connor's proposal, which are… which is perfect.

688
01:25:23.780 --> 01:25:28.240
Francisco.Ortin@cit.ie: is doing like this, okay? So this is the right recursive.

689
01:25:28.410 --> 01:25:30.160
Francisco.Ortin@cit.ie: And this is the left recursive.

690
01:25:36.340 --> 01:25:38.190
Francisco.Ortin@cit.ie: Okay, these are the two solutions.

691
01:25:39.150 --> 01:25:48.720
Francisco.Ortin@cit.ie: Okay, let's go to the first one, trying to derive the first one. Well, the first one here, this one is the first one, is L implies A.

692
01:25:48.830 --> 01:25:49.870
Francisco.Ortin@cit.ie: Very simple.

693
01:25:50.060 --> 01:25:55.670
Francisco.Ortin@cit.ie: The second one, we derive, instead of using the first one, I'm gonna use this one.

694
01:25:56.010 --> 01:26:00.260
Francisco.Ortin@cit.ie: So, I'm choosing the second one. So, this is A comma L.

695
01:26:00.960 --> 01:26:10.500
Francisco.Ortin@cit.ie: Again, here, I'm choosing the first one, and I'm replacing this L with A, A comma A. So that's the demonstration of the second one. Let's go to the third one.

696
01:26:11.480 --> 01:26:21.060
Francisco.Ortin@cit.ie: Starts as second one, so it's second production, A comma L, and here, instead of applying first… whoops, I'm going to apply 2 again.

697
01:26:21.230 --> 01:26:26.610
Francisco.Ortin@cit.ie: So this is going to be A, comma, A, comma L.

698
01:26:26.770 --> 01:26:35.329
Francisco.Ortin@cit.ie: And this, applying the first one, is A comma A. So both solutions, these three solo… well, three solutions are perfect.

699
01:26:35.840 --> 01:26:36.540
Francisco.Ortin@cit.ie: Okay?

700
01:26:36.950 --> 01:26:42.319
Francisco.Ortin@cit.ie: Very good, good job. Notice a yes, I know, I know, you have to practice. It's always a matter of practicing.

701
01:26:42.520 --> 01:26:47.579
Francisco.Ortin@cit.ie: Okay, very good. So now goes the most difficult one. Number 4 is the most difficult.

702
01:26:47.890 --> 01:26:53.970
Francisco.Ortin@cit.ie: So far, we've managed We've managed to do it with just one production.

703
01:26:54.250 --> 01:27:09.159
Francisco.Ortin@cit.ie: Don't try to do this with… this one with one protection, okay? You can… you can try to do it at home if you want, but that's impossible, okay? So if you want to practice, that's okay, but a hint is here, a clue is that it's not possible, okay?

704
01:27:09.960 --> 01:27:13.210
Francisco.Ortin@cit.ie: And here, question mark means optional.

705
01:27:13.480 --> 01:27:19.569
Francisco.Ortin@cit.ie: So this is telling you, okay, this is optional. So epsilon is included. So epsilon is one option.

706
01:27:19.700 --> 01:27:21.700
Francisco.Ortin@cit.ie: So it's the same as the previous one?

707
01:27:21.880 --> 01:27:25.769
Francisco.Ortin@cit.ie: Okay, but epsilon is included, so I'm gonna write here a new.

708
01:27:26.770 --> 01:27:33.350
Francisco.Ortin@cit.ie: note, and I'm right here the example. So this is language number 4, which is the most difficult one.

709
01:27:33.500 --> 01:27:41.270
Francisco.Ortin@cit.ie: Okay, so take your time. And examples are epsilon, are… 8?

710
01:27:41.500 --> 01:27:44.560
Francisco.Ortin@cit.ie: an A comma A, and then so on and so forth.

711
01:27:45.280 --> 01:27:49.950
Francisco.Ortin@cit.ie: Okay, and always… Try to write list implies.

712
01:27:55.780 --> 01:28:05.980
Francisco.Ortin@cit.ie: I always try to do it as simple as possible, and this is super important in the labs, okay? Because otherwise it's going to be a nightmare. Every time you have to modify something, it takes a lot of time.

713
01:28:09.990 --> 01:28:14.310
Francisco.Ortin@cit.ie: So it's always worth investing your time and make it as simple as possible.

714
01:28:24.750 --> 01:28:29.230
Francisco.Ortin@cit.ie: Very good, very good, Dimitris, and…

715
01:28:33.360 --> 01:28:37.810
Francisco.Ortin@cit.ie: But, Rudolph, in your proposal, you don't accept epsilon.

716
01:28:37.970 --> 01:28:52.179
Francisco.Ortin@cit.ie: it's almost perfect, but there's something there that should be changed. Okay, very good. I know Rudolph now's the answer, so does Dimitris, and you keep practicing, and you're gonna get it. So, if you analyze this, Language 4,

717
01:28:52.450 --> 01:28:56.359
Francisco.Ortin@cit.ie: Then you realize that this is language 3, including epsilon.

718
01:28:57.230 --> 01:29:02.649
Francisco.Ortin@cit.ie: All right, so if we already have language 3, it's as simple as saying epsilon.

719
01:29:03.390 --> 01:29:05.820
Francisco.Ortin@cit.ie: OR, and then language 3.

720
01:29:05.970 --> 01:29:15.840
Francisco.Ortin@cit.ie: Okay? Language 3 was a repetition of at least 1A, so we may say list… 1A.

721
01:29:16.860 --> 01:29:30.159
Francisco.Ortin@cit.ie: at least… 1A… is… Sorry, I, I, I… Road, wrong arrow here.

722
01:29:31.740 --> 01:29:38.240
Francisco.Ortin@cit.ie: And this 1A is language 3, that if you remember, is A.

723
01:29:38.550 --> 01:29:45.360
Francisco.Ortin@cit.ie: Or… at least… 1A…

724
01:29:46.360 --> 01:29:52.599
Francisco.Ortin@cit.ie: Comma, A, which is what some of you… yeah, very good, exactly, very good. That's the idea.

725
01:29:52.970 --> 01:29:56.469
Francisco.Ortin@cit.ie: Okay, let's again practice and see if this works.

726
01:29:57.340 --> 01:30:01.160
Francisco.Ortin@cit.ie: list, okay, Epsilon, first production.

727
01:30:02.070 --> 01:30:06.649
Francisco.Ortin@cit.ie: Okay, I'm gonna write first, second, third, and fourth.

728
01:30:09.070 --> 01:30:11.130
Francisco.Ortin@cit.ie: So this is epsilon, demonstrated.

729
01:30:11.460 --> 01:30:15.840
Francisco.Ortin@cit.ie: So, list here is going to imply the second protection.

730
01:30:16.200 --> 01:30:21.420
Francisco.Ortin@cit.ie: Second production. Sorry, I'll go that fast. Take your time. At least one.

731
01:30:21.830 --> 01:30:26.949
Francisco.Ortin@cit.ie: list… Go on, okay?

732
01:30:28.110 --> 01:30:29.510
Francisco.Ortin@cit.ie: 1A, sorry.

733
01:30:32.460 --> 01:30:40.429
Francisco.Ortin@cit.ie: And then we have to decide which is the one to be derived. So, in this case, it's very simple, it's number 3.

734
01:30:41.140 --> 01:30:44.800
Francisco.Ortin@cit.ie: Because we have to provide aid. So again, demonstration.

735
01:30:45.560 --> 01:30:46.450
Francisco.Ortin@cit.ie: Okay?

736
01:30:46.560 --> 01:30:51.970
Francisco.Ortin@cit.ie: List implies that the second projection, at least 1A…

737
01:30:52.150 --> 01:31:05.330
Francisco.Ortin@cit.ie: Which here, obviously, we have to take production number 4. So we're replacing this at least 1A, with… 1A…

738
01:31:05.590 --> 01:31:12.129
Francisco.Ortin@cit.ie: Coma… A. Here, be careful, because this may be…

739
01:31:12.620 --> 01:31:14.969
Francisco.Ortin@cit.ie: Some, some, some of you may be…

740
01:31:15.150 --> 01:31:18.830
Francisco.Ortin@cit.ie: thinking that… sorry, I'm gonna try to raise this.

741
01:31:19.860 --> 01:31:20.540
Francisco.Ortin@cit.ie: Come on.

742
01:31:20.730 --> 01:31:27.650
Francisco.Ortin@cit.ie: And I'm gonna say… 1A goes together, so this is not token A, okay? And then here, I'm gonna…

743
01:31:27.970 --> 01:31:37.219
Francisco.Ortin@cit.ie: derived with production number 3, so that this is going to be replaced with A. So we have A, comma A. So again, demonstration that this is the same.

744
01:31:37.540 --> 01:31:38.390
Francisco.Ortin@cit.ie: Okay?

745
01:31:38.860 --> 01:31:42.710
Francisco.Ortin@cit.ie: We wanna do it, write recursive.

746
01:31:42.900 --> 01:31:44.719
Francisco.Ortin@cit.ie: It's just changing this.

747
01:31:46.310 --> 01:31:57.199
Francisco.Ortin@cit.ie: So that is, at least 1A implies A, or… A, comma, at least 1A.

748
01:31:57.400 --> 01:32:07.529
Francisco.Ortin@cit.ie: All right? So again, if you divide into two different non-terminals, so in other words, if you add a new terminal to it, it's just reducing the previous production.

749
01:32:07.840 --> 01:32:20.639
Francisco.Ortin@cit.ie: This is exactly what you have to try to do in the labs, okay? It's very similar to programming, it's very similar to programming. I have something, I have just created one function, then I'm creating another function that extends the other one.

750
01:32:20.640 --> 01:32:31.490
Francisco.Ortin@cit.ie: what I'm doing, copying and pasting the code? No, man, you're creating another function that calls the first one, and that's exactly the same, okay? Non-terminals are like functions. You will realize that actually Ampler translates

751
01:32:31.490 --> 01:32:36.119
Francisco.Ortin@cit.ie: translate, sorry, every non-terminent to a function. So it's the exact same technique.

752
01:32:36.560 --> 01:32:41.889
Francisco.Ortin@cit.ie: What about language number 5? In language number 5, Which is super simple.

753
01:32:43.410 --> 01:32:46.150
Francisco.Ortin@cit.ie: Language number file is a,

754
01:32:46.270 --> 01:32:50.040
Francisco.Ortin@cit.ie: Instead of the limiter, and instead of,

755
01:32:51.430 --> 01:32:58.589
Francisco.Ortin@cit.ie: Common separated, what is what we have here, we have what is called the limiter, so it's always semicolon. So if you have one.

756
01:32:58.840 --> 01:33:08.180
Francisco.Ortin@cit.ie: you have two, you need to duplicate the semicolon. So this is not a delimiter anymore, because you need, after the last one, another one. Okay, so this is language 3.

757
01:33:08.450 --> 01:33:15.309
Francisco.Ortin@cit.ie: Okay? The 4 and 3 were, separators, and here we have a denimeter.

758
01:33:16.460 --> 01:33:24.309
Francisco.Ortin@cit.ie: Okay? So the examples are… Epsilon, or a semicolon, or a semicolon.

759
01:33:24.900 --> 01:33:30.749
Francisco.Ortin@cit.ie: a semicolon, and so on and so forth. These are four different tokens, by the way. Two tokens here, alright?

760
01:33:31.320 --> 01:33:34.330
Francisco.Ortin@cit.ie: So, what's the language? This is a very simple language.

761
01:33:36.630 --> 01:33:44.720
Francisco.Ortin@cit.ie: Again, if you take a look at this, it's a particular case scenario of language number 2, because it's a repetitions

762
01:33:45.680 --> 01:34:04.620
Francisco.Ortin@cit.ie: is a repetition including epsilon, but instead of one token, you have two tokens altogether, one after the other one, all right? So it's just the same pattern as language two. So language 3 is a case… a base case, is a example, case scenario of language 2.

763
01:34:05.080 --> 01:34:14.700
Francisco.Ortin@cit.ie: So, since epsilon is included, we have epsilon here, or, and then if we're using, for instance, right recursion, we have A,

764
01:34:15.000 --> 01:34:16.750
Francisco.Ortin@cit.ie: Semicolon list.

765
01:34:17.710 --> 01:34:21.480
Francisco.Ortin@cit.ie: Okay, if you want to do it left recursive, it's this.

766
01:34:21.680 --> 01:34:25.660
Francisco.Ortin@cit.ie: You… if you take a look at solution number 2, I'll go back there.

767
01:34:25.900 --> 01:34:28.659
Francisco.Ortin@cit.ie: You'll see that this is exactly the same solution.

768
01:34:28.930 --> 01:34:36.929
Francisco.Ortin@cit.ie: Epsilon, or list, a semicolon. The only difference here is that here we have two tokens.

769
01:34:37.240 --> 01:34:43.779
Francisco.Ortin@cit.ie: Instead of 1. In other words, if you just get rid of semicolon, you'll see that it's example number 2, so this is…

770
01:34:44.260 --> 01:34:47.130
Francisco.Ortin@cit.ie: Oh, I don't know what the sample number 24, 32?

771
01:34:47.290 --> 01:34:48.650
Francisco.Ortin@cit.ie: Is this one here?

772
01:34:49.690 --> 01:34:50.400
Francisco.Ortin@cit.ie: Oh.

773
01:34:51.200 --> 01:34:52.560
Francisco.Ortin@cit.ie: Where is it? Sorry.

774
01:34:52.710 --> 01:34:54.629
Francisco.Ortin@cit.ie: And I'll use the mouse better.

775
01:34:58.870 --> 01:35:03.190
Francisco.Ortin@cit.ie: For some reason, they're not ordered. I should… I think I changed something.

776
01:35:03.370 --> 01:35:04.920
Francisco.Ortin@cit.ie: 3, 2…

777
01:35:05.850 --> 01:35:11.940
Francisco.Ortin@cit.ie: There you are. Okay, so here, what I'm adding is semicolon here, and that's exactly the same solution, okay?

778
01:35:12.080 --> 01:35:13.940
Francisco.Ortin@cit.ie: Any questions? Any comments?

779
01:35:14.160 --> 01:35:31.989
Francisco.Ortin@cit.ie: So always try to practice with those activities. Some of them are going to be done in the lecture, some of them are, like, homework for you to practice before the lab. So it's better always try to practice, and then you go to the lab. Many of the things you already have is just copying and pasting, okay? So…

780
01:35:32.310 --> 01:35:34.269
Francisco.Ortin@cit.ie: The practice, the more you practice, the better.

781
01:35:36.050 --> 01:35:47.190
Francisco.Ortin@cit.ie: Okay, so this is one example of activity you may do as homework. It's optional and autonomous. So, do you remember… you probably remember that this language was, not a regular language.

782
01:35:47.390 --> 01:35:57.839
Francisco.Ortin@cit.ie: So, I'm telling you, this is context-free, language, so it can be specified. It can spec… it can be specified with our context-free grammar.

783
01:35:58.100 --> 01:36:13.290
Francisco.Ortin@cit.ie: Right? So, one, activity is not very difficult, is the same as we did here with lists, try to write the description of the context-free grammar that recognizes this. If you want to do it, you can send me an email… well, a Canvas inbox message.

784
01:36:13.500 --> 01:36:15.809
Francisco.Ortin@cit.ie: And I'll tell you if this is correct or not.

785
01:36:16.440 --> 01:36:22.059
Francisco.Ortin@cit.ie: Okay, so let's move to Antler. So far, we've used the canonical approach, which is the

786
01:36:22.310 --> 01:36:26.989
Francisco.Ortin@cit.ie: kind of verbose, because you need a lot of recursion, as Dimitri was saying.

787
01:36:31.230 --> 01:36:33.089
Francisco.Ortin@cit.ie: So, in order to make it,

788
01:36:33.940 --> 01:36:40.160
Francisco.Ortin@cit.ie: More, concise, the language specification, you may use more operators.

789
01:36:40.720 --> 01:36:45.720
Francisco.Ortin@cit.ie: So, Antler has extended VNF notation, and it uses…

790
01:36:45.840 --> 01:36:51.080
Francisco.Ortin@cit.ie: Many different operators taken from regular expressions to make,

791
01:36:51.200 --> 01:37:04.990
Francisco.Ortin@cit.ie: language description more compact. So it's not giving extra expressiveness, okay? But it's allowing you to write the grammars in just a few lines of language specifications, all right?

792
01:37:06.000 --> 01:37:25.230
Francisco.Ortin@cit.ie: So, remember, if you have, terminal, non-terminals, in Antler, you may use this pipe operator to say OR, okay? Actually, we've been already using that here. You can see how you're using OR, okay? So, if this is actually a new production, you write like this.

793
01:37:25.320 --> 01:37:27.780
Francisco.Ortin@cit.ie: But if you want to have A or B,

794
01:37:28.550 --> 01:37:30.270
Francisco.Ortin@cit.ie: We even have A but B.

795
01:37:30.920 --> 01:37:39.320
Francisco.Ortin@cit.ie: like, let's say, C followed by A or B, and then D, you can write like this, A or…

796
01:37:40.030 --> 01:37:46.350
Francisco.Ortin@cit.ie: B, okay? So this is C, followed by A or B, And then D.

797
01:37:46.520 --> 01:37:53.250
Francisco.Ortin@cit.ie: Be careful, because if you delete the parentheses, this actually means C…

798
01:37:53.460 --> 01:37:58.820
Francisco.Ortin@cit.ie: followed by A, or B followed by D. Obviously, it's different, okay? Be careful with that.

799
01:37:59.010 --> 01:37:59.740
Francisco.Ortin@cit.ie: Okay?

800
01:38:00.340 --> 01:38:05.139
Francisco.Ortin@cit.ie: Good. That's why always writing a new production in a new line is going to be helpful, okay?

801
01:38:05.550 --> 01:38:15.210
Francisco.Ortin@cit.ie: Great, so I was here, yes. If you write one after the other one is concatenation, well, that's… that's not an extra operator. You have CleanStar for…

802
01:38:15.320 --> 01:38:23.200
Francisco.Ortin@cit.ie: or clean closure, or zero or more repetitions. You also have PLUS, which is at least one occurrence repetition.

803
01:38:23.380 --> 01:38:29.639
Francisco.Ortin@cit.ie: So, R plus is the same as RR star, but you, you know, it's more compact.

804
01:38:29.820 --> 01:38:39.020
Francisco.Ortin@cit.ie: And then this question mark for optionality, okay? So if you write, a question mark, View ride.

805
01:38:42.160 --> 01:38:52.129
Francisco.Ortin@cit.ie: List implies… a question mark, this means that A could occur, or epsilon. If you want more characters.

806
01:38:52.340 --> 01:39:00.390
Francisco.Ortin@cit.ie: to be optional, then you need parentheses, because otherwise it's just the previous one, it's just B, okay? So, those things are important.

807
01:39:01.570 --> 01:39:08.030
Francisco.Ortin@cit.ie: Okay, question. Using an extended VNN, write language 4. Do you remember Language 4 with these ones?

808
01:39:08.180 --> 01:39:10.369
Francisco.Ortin@cit.ie: Okay, which was the most difficult one.

809
01:39:10.520 --> 01:39:14.619
Francisco.Ortin@cit.ie: So, using this, we have to be able to write

810
01:39:14.760 --> 01:39:23.860
Francisco.Ortin@cit.ie: a simpler context-free grammar for recognizing this language, because we have more tools, right? So, language 4

811
01:39:24.220 --> 01:39:28.480
Francisco.Ortin@cit.ie: was… I'm gonna take it from here, sorry for that, I don't know what happened like this.

812
01:39:29.540 --> 01:39:34.010
Francisco.Ortin@cit.ie: Okay, so I'm gonna take Language 4, which was this one here.

813
01:39:35.340 --> 01:39:36.480
Francisco.Ortin@cit.ie: I'm gonna copy.

814
01:39:39.280 --> 01:39:40.699
Francisco.Ortin@cit.ie: At least try to copy.

815
01:39:42.590 --> 01:39:43.790
Francisco.Ortin@cit.ie: Ctrl-C.

816
01:39:47.090 --> 01:39:48.119
Francisco.Ortin@cit.ie: And paste it here.

817
01:39:49.090 --> 01:39:51.800
Francisco.Ortin@cit.ie: So, this is the original language, okay?

818
01:39:52.480 --> 01:39:55.180
Francisco.Ortin@cit.ie: Here I have… Too odd.

819
01:39:59.470 --> 01:40:00.730
Francisco.Ortin@cit.ie: Comma A.

820
01:40:01.840 --> 01:40:03.969
Francisco.Ortin@cit.ie: Comma A. This is the original language.

821
01:40:06.060 --> 01:40:10.109
Francisco.Ortin@cit.ie: Okay, how do you write this using Antler notation?

822
01:40:10.600 --> 01:40:13.440
Francisco.Ortin@cit.ie: So, obviously, it's gonna be LIST.

823
01:40:16.360 --> 01:40:17.380
Francisco.Ortin@cit.ie: implies.

824
01:40:17.800 --> 01:40:19.360
Francisco.Ortin@cit.ie: This is the BN app.

825
01:40:20.600 --> 01:40:22.900
Francisco.Ortin@cit.ie: And this is the antler.

826
01:40:25.950 --> 01:40:27.250
Francisco.Ortin@cit.ie: extended VNF.

827
01:40:29.190 --> 01:40:30.609
Francisco.Ortin@cit.ie: So, what do you propose?

828
01:40:30.710 --> 01:40:32.219
Francisco.Ortin@cit.ie: List implies what?

829
01:40:34.370 --> 01:40:36.500
Francisco.Ortin@cit.ie: You may use those operators.

830
01:40:39.330 --> 01:40:40.690
Francisco.Ortin@cit.ie: Very good.

831
01:40:41.260 --> 01:40:47.140
Francisco.Ortin@cit.ie: So, Rulo proposes… Very good, thank you, Rudolph. A. Starr.

832
01:40:47.960 --> 01:40:52.759
Francisco.Ortin@cit.ie: parenthesis, comma, A, and everything star.

833
01:40:53.760 --> 01:40:54.859
Francisco.Ortin@cit.ie: What do you think?

834
01:40:58.020 --> 01:41:04.409
Francisco.Ortin@cit.ie: all the programs here, like A, A, comma A.

835
01:41:04.650 --> 01:41:13.450
Francisco.Ortin@cit.ie: Epsilon and A comma A comma A, which are recognized by this language, are also recognized by this one. But, there's a but here.

836
01:41:13.560 --> 01:41:19.229
Francisco.Ortin@cit.ie: If you concentrate on this, this is allowing this program, and it shouldn't be allowed.

837
01:41:19.580 --> 01:41:25.040
Francisco.Ortin@cit.ie: Okay? So that's almost correct, but there's something here that is not correct.

838
01:41:25.250 --> 01:41:31.029
Francisco.Ortin@cit.ie: So how can we make this to be… improve this so that it solves our problem?

839
01:41:31.620 --> 01:41:37.729
Francisco.Ortin@cit.ie: We shouldn't have used here plain star, because it allows you those repetitions, okay?

840
01:41:38.490 --> 01:41:44.410
Francisco.Ortin@cit.ie: So now this is better, but we still have one problem, that A is mandatory.

841
01:41:44.600 --> 01:41:49.629
Francisco.Ortin@cit.ie: And in this language, epsilon could be… should be allowed. So how do… how do we…

842
01:41:49.970 --> 01:42:02.029
Francisco.Ortin@cit.ie: Yeah, there are different options here. Well, that one, that one rule, if you take a look at it, allows you to have a optional, and then comma A, comma, comma, so the input comma A, comma, comma should not be allowed.

843
01:42:02.790 --> 01:42:03.550
Francisco.Ortin@cit.ie: Alright?

844
01:42:03.710 --> 01:42:15.109
Francisco.Ortin@cit.ie: But you're improving, you're moving forward. No problem, no problem, let's always try and try and try. So how can we modify this production here I have here, so that epsilon is included? There are two ways of doing that.

845
01:42:18.420 --> 01:42:20.390
Dmitrijs Dubrovs: But isn't that correct, though?

846
01:42:21.390 --> 01:42:28.660
Francisco.Ortin@cit.ie: I don't see your solution right now. I'm just taking a look at… I just can't read in the chat. Let me watch the chat.

847
01:42:28.660 --> 01:42:31.150
Dmitrijs Dubrovs: Oh, no, it's… it's missing the.

848
01:42:31.150 --> 01:42:31.790
Francisco.Ortin@cit.ie: Sure.

849
01:42:32.370 --> 01:42:35.550
Dmitrijs Dubrovs: As it is now, right, it is the…

850
01:42:35.960 --> 01:42:40.449
Dmitrijs Dubrovs: concentration, like, the union of… well, not the union, sorry.

851
01:42:40.700 --> 01:42:42.729
Francisco.Ortin@cit.ie: Lisa proposes this one. What do you think?

852
01:42:43.950 --> 01:42:52.499
Francisco.Ortin@cit.ie: This is a very correct option. This is perfect, actually, because everything could be optional. And another one, very common, as well, is this one.

853
01:42:53.240 --> 01:42:56.150
Francisco.Ortin@cit.ie: Which is somehow connected to the one you're proposing, Dimitri.

854
01:42:56.610 --> 01:42:57.280
Francisco.Ortin@cit.ie: Okay?

855
01:42:57.700 --> 01:42:59.230
Francisco.Ortin@cit.ie: These two languages?

856
01:42:59.570 --> 01:43:05.370
Francisco.Ortin@cit.ie: This one and this one, they're equivalent, okay? Because they recognize the same language.

857
01:43:05.650 --> 01:43:10.760
Francisco.Ortin@cit.ie: Okay, remember that another option was this one here. I'm gonna write it here again.

858
01:43:11.480 --> 01:43:13.439
Francisco.Ortin@cit.ie: And this is the one I'm living, because

859
01:43:13.610 --> 01:43:15.799
Francisco.Ortin@cit.ie: is the one that Felipe proposed.

860
01:43:16.140 --> 01:43:18.350
Francisco.Ortin@cit.ie: Okay, this one here. Great!

861
01:43:18.570 --> 01:43:25.620
Francisco.Ortin@cit.ie: So you can see how, using those operators, you can make your projections to be More readable, okay?

862
01:43:26.890 --> 01:43:31.199
Francisco.Ortin@cit.ie: Great, great. Good, good. So we're practicing a little with Antler.

863
01:43:32.080 --> 01:43:34.490
Francisco.Ortin@cit.ie: At least with extended B and F notation.

864
01:43:34.890 --> 01:43:40.749
Francisco.Ortin@cit.ie: So now here we have… we now move forward to the last part of the… of the… this unit.

865
01:43:40.860 --> 01:43:45.770
Francisco.Ortin@cit.ie: It's gonna take some time, because now we have to move from theory into implementation.

866
01:43:46.140 --> 01:43:57.759
Francisco.Ortin@cit.ie: We have to practice with Ankler and be able to generate Java implementations of lectures, okay? So this is going to be for Lab 3, because I don't have time for doing in just one lecture.

867
01:43:57.880 --> 01:44:04.150
Francisco.Ortin@cit.ie: Okay? But in Lecture 3, you… and Lab 3, you will practice with Antler grading, lexors.

868
01:44:04.390 --> 01:44:12.610
Francisco.Ortin@cit.ie: So remember, Alexa are specified using contact-free grammars, Huh? And those…

869
01:44:13.090 --> 01:44:19.349
Francisco.Ortin@cit.ie: Grammars that are actually representing patterns of the tokens to be identified.

870
01:44:19.890 --> 01:44:20.650
Francisco.Ortin@cit.ie: Okay?

871
01:44:20.850 --> 01:44:24.560
Francisco.Ortin@cit.ie: So… The way we define Alexa.

872
01:44:24.940 --> 01:44:31.949
Francisco.Ortin@cit.ie: is by describing those patterns. In other words, describing the context-free productions.

873
01:44:32.100 --> 01:44:39.580
Francisco.Ortin@cit.ie: that recognize each token. So, for instance, for… this is the production for identifier.

874
01:44:39.870 --> 01:44:49.349
Francisco.Ortin@cit.ie: And then identifier is, like, a letter followed by any letter or digit, for instance. That could be a parameter. And you specify it with a context-free grammar.

875
01:44:49.510 --> 01:44:53.880
Francisco.Ortin@cit.ie: Once you have that specification, you can implement it in two different ways.

876
01:44:54.040 --> 01:45:02.990
Francisco.Ortin@cit.ie: By checking, doing it, manually, so it's like a programming activity, first or… first year of programming, in computer science.

877
01:45:03.340 --> 01:45:10.519
Francisco.Ortin@cit.ie: And this is a very good activity, but it's much faster to pass it to a tool and let the tool generate the Lexa for you.

878
01:45:10.680 --> 01:45:11.420
Francisco.Ortin@cit.ie: Okay?

879
01:45:12.030 --> 01:45:25.059
Francisco.Ortin@cit.ie: I'm saying it this way, because programming the totem is kind of easy, but it's much faster using a tool. But when it comes to syntax analysis, running the parser is so, so difficult.

880
01:45:25.440 --> 01:45:33.600
Francisco.Ortin@cit.ie: And this is related to some of you asking me a question about who's deciding what's the production to be selected.

881
01:45:34.140 --> 01:45:37.470
Francisco.Ortin@cit.ie: Since that's complicated, then…

882
01:45:37.640 --> 01:45:49.919
Francisco.Ortin@cit.ie: Antler is gonna do a lot of work that you don't have to program, okay? So again, in Lexing, programming is an option, but in parsing is so, so difficult, okay? It's always an option, of course, but it's so difficult.

883
01:45:50.180 --> 01:46:02.720
Francisco.Ortin@cit.ie: Right? So you're going to use Antler for both lexical and syntax analyzer generation. Okay, so something about Antler. Antler stands for another tool for language recognition, but, well, it's,

884
01:46:03.110 --> 01:46:18.680
Francisco.Ortin@cit.ie: I'm going to explain that about… about this later in parsing. It's actually… it comes from anti-LR, because LR is another architecture for this kind of tool, so we'll explain that later, all right? Now, it stands yes for another language recognition.

885
01:46:19.100 --> 01:46:34.350
Francisco.Ortin@cit.ie: It generates parsons and lectures, and it also provides you with grammars for not just characters, binary code, and tokens, but also trees. So it allows you to implement visitors using,

886
01:46:34.950 --> 01:46:42.440
Francisco.Ortin@cit.ie: tree grammars, okay? This is… this part is kind of complicated, and I don't think the learning cure,

887
01:46:43.860 --> 01:46:55.799
Francisco.Ortin@cit.ie: is worth for what you're doing if you're implementing a real complier. So, in other words, we're not going to use three workers. That's an option I'm not going to use because, they are complicated, and they're not that

888
01:46:56.110 --> 01:46:57.590
Francisco.Ortin@cit.ie: Powerful, alright?

889
01:46:57.960 --> 01:47:17.949
Francisco.Ortin@cit.ie: It's widely used for… in many different companies, for many different tools, okay? There you have some examples, okay, but now Antler is the language processing tool. So if you want to process some tool of data structure, and you want to do it with content-free grammar, Antler is by far the best tool, right?

890
01:47:18.380 --> 01:47:24.060
Francisco.Ortin@cit.ie: time ago, there were more options. Nowadays, it's the best one, right?

891
01:47:24.370 --> 01:47:39.710
Francisco.Ortin@cit.ie: And it also has many different grammars, okay? We've used this for many purposes, like research, but if you want to take a look at grammar of any language, you go to Antler webpage, and you have a lot of grammars. Of course, there are so,

892
01:47:39.840 --> 01:47:44.889
Francisco.Ortin@cit.ie: verbose, they have a lot of productions, because real languages, they do have a lot of options, okay?

893
01:47:45.210 --> 01:47:50.860
Francisco.Ortin@cit.ie: Python, for example, is a very, very complicated, from the syntax point of view, programming language, okay?

894
01:47:51.040 --> 01:48:05.869
Francisco.Ortin@cit.ie: And all versions of C, they are very, very kind of easy, but new versions are also complicated. So real programming languages, they're complicated. And the code that Anfer generates includes these language… programming languages. So if you want to program any

895
01:48:06.010 --> 01:48:08.489
Francisco.Ortin@cit.ie: context-free grammar and process it is with,

896
01:48:08.550 --> 01:48:24.389
Francisco.Ortin@cit.ie: one of these languages, you can use Antler for that, okay? It's developed by Professor Terrence Parr, that was a former professor, full professor in the University of San Francisco, now is, working at Google, okay? Very important, we're going to use Antler

897
01:48:24.410 --> 01:48:33.359
Francisco.Ortin@cit.ie: 4, version whatever, okay? So if you're not using 4, it's not going to work, which you have in the slide. So if you have version 3 or… or lower.

898
01:48:33.510 --> 01:48:37.689
Francisco.Ortin@cit.ie: that's not gonna work, okay? So at least version 4.

899
01:48:38.940 --> 01:48:44.150
Francisco.Ortin@cit.ie: Okay, so as a black box, how Amplorer works is the following way.

900
01:48:44.640 --> 01:48:53.519
Francisco.Ortin@cit.ie: So you describe your lecture and parser using context-free grammars in one notation, which is very close to E, B, and F.

901
01:48:53.690 --> 01:49:06.749
Francisco.Ortin@cit.ie: we describe here in this activity. So, very similar to this, okay? And then you pass it to Antler, and Antler generates, many files, but the two most important files for us are

902
01:49:06.850 --> 01:49:19.129
Francisco.Ortin@cit.ie: the Lexer implementation and the person implementation, and that's how it works, okay? So right now, in this, unit, we're gonna just, specify Lexars. But next unit, we're gonna…

903
01:49:19.270 --> 01:49:22.730
Francisco.Ortin@cit.ie: Take the lexer and specify also the parser.

904
01:49:22.850 --> 01:49:36.510
Francisco.Ortin@cit.ie: Okay? So it's… it's kind of cool, because it mixes both Lexer and parser, and it uses the same approach, so it's very easy. Once you get, fluent with Angler, it's valid for both legs and parser, which is, good.

905
01:49:37.210 --> 01:49:51.089
Francisco.Ortin@cit.ie: Okay, so now we're gonna open the box, and we're gonna take a look at this class here. This is a file that implements my lecture class. So if you're saying, okay, my language is my LANG G4, stands for

906
01:49:51.150 --> 01:50:06.449
Francisco.Ortin@cit.ie: grammar version 4, because we're using Anthony 4, then it's going to generate a class called mylanglexer.java. So if you just remove a Java file, then this is a class that has an interface, all right? Public methods and fields.

907
01:50:06.550 --> 01:50:12.030
Francisco.Ortin@cit.ie: So, next slide is going to open this box and show you what's the interface of that class, all right?

908
01:50:12.140 --> 01:50:14.989
Francisco.Ortin@cit.ie: So the best… the first bet question is.

909
01:50:15.130 --> 01:50:19.160
Francisco.Ortin@cit.ie: What's the method that you have to call to get the next token?

910
01:50:19.270 --> 01:50:23.649
Francisco.Ortin@cit.ie: Okay? So this algorithm is as simple as creating one instance of this class.

911
01:50:23.870 --> 01:50:31.070
Francisco.Ortin@cit.ie: Okay, and then call in next token, next token, next token. So it's just one method you have to know, okay? And nothing else.

912
01:50:31.450 --> 01:50:41.330
Francisco.Ortin@cit.ie: So this method is returning the first time you call it the first token, and second, and so on and so forth, okay? Of course, you will have to know when there are more… no more tokens to be,

913
01:50:41.730 --> 01:50:42.650
Francisco.Ortin@cit.ie: retrieved.

914
01:50:42.960 --> 01:50:50.380
Francisco.Ortin@cit.ie: Okay? But this is the only, the only method, okay? As you can see, Token is returned.

915
01:50:50.570 --> 01:50:59.260
Francisco.Ortin@cit.ie: it's not actually an integer, it's an object. And the integer is going to be inside that object. So, once we understand that next token is the only method in the

916
01:51:00.360 --> 01:51:02.290
Francisco.Ortin@cit.ie: a facade of my lexer.

917
01:51:02.800 --> 01:51:11.019
Francisco.Ortin@cit.ie: What's… what's then the interface of token? So which are the methods and the attributes of token? So that's gonna be described next.

918
01:51:11.270 --> 01:51:14.920
Francisco.Ortin@cit.ie: So once you call next token, you get a token, what do I do with the token?

919
01:51:15.200 --> 01:51:17.710
Francisco.Ortin@cit.ie: So, if you call getType, then you have

920
01:51:17.880 --> 01:51:31.399
Francisco.Ortin@cit.ie: the token, okay? That integer I've been speaking about, in my lecture, right? That some students say, okay, is that the type? Exactly, so it's called get type. So you want to get the integer that represents the token, you call getType.

921
01:51:31.720 --> 01:51:44.660
Francisco.Ortin@cit.ie: Okay? These types are going to be generated, you don't have to describe them, they're going to be generated in the class as public static final fields. So we're saying, okay, I have a token called ID,

922
01:51:44.660 --> 01:51:57.530
Francisco.Ortin@cit.ie: then ID is going to be a public static final field, so if you prefer a constant attribute, in the parser and Lexar class. And this, in my slide, I'm using parser because in previous version.

923
01:51:57.610 --> 01:52:04.699
Francisco.Ortin@cit.ie: versions only was introduced in the parser, but now Antler generates both in the lecture and the parser, so you access to the

924
01:52:05.000 --> 01:52:06.570
Francisco.Ortin@cit.ie: Lexo clause, that's correct.

925
01:52:07.190 --> 01:52:07.890
Francisco.Ortin@cit.ie: Okay?

926
01:52:08.000 --> 01:52:24.460
Francisco.Ortin@cit.ie: So, once I know how to get the token, another question could be, okay, how do I get the no more tokens token? How can I possibly get the token that is returned and know that there are no more tokens to be retrieved?

927
01:52:25.020 --> 01:52:31.599
Francisco.Ortin@cit.ie: So, you go to the parser class, and you ask for this predefined token. You don't have to define called

928
01:52:32.050 --> 01:52:33.340
Francisco.Ortin@cit.ie: and all files.

929
01:52:33.920 --> 01:52:39.609
Francisco.Ortin@cit.ie: Okay? So if the token that is returned, its type, The token that is returned.

930
01:52:40.670 --> 01:52:42.100
Francisco.Ortin@cit.ie: You get its type.

931
01:52:42.450 --> 01:52:44.789
Francisco.Ortin@cit.ie: And this type is AOF.

932
01:52:45.020 --> 01:53:04.800
Francisco.Ortin@cit.ie: then you know that there are no more tokens to be read. Every time you call next token, you're gonna get EOF, EOF, EOF, okay? So that's why, you're gonna need it in Lab 3. As a loop. Every time I get something different from EOF, I keep asking… keep asking, sorry, next token I gets… okay?

933
01:53:04.890 --> 01:53:20.729
Francisco.Ortin@cit.ie: So definitely, this is the most important method. Then we have getLine for knowing where's, where was the line of the token. We don't have getColumn, and this is kind of curious, because, columns are not that simple when you have

934
01:53:21.840 --> 01:53:23.370
Francisco.Ortin@cit.ie: When you have an input file.

935
01:53:23.560 --> 01:53:26.360
Francisco.Ortin@cit.ie: Okay? Because you may have something like here.

936
01:53:26.560 --> 01:53:38.990
Francisco.Ortin@cit.ie: The column of this A is column number 1, because it's the first one. Okay, this is number 1. You may have a blank, and a blank, and here A, column is 3, but what happens if I'm writing here a tabular?

937
01:53:39.300 --> 01:53:56.570
Francisco.Ortin@cit.ie: Okay, what's the column of A? That's kind of difficult, because some people may say those are four characters, but actually depends on the editor, okay? And that's why this guy, Charon Powers, instead of using get column, it wrote getCarPositionInLine, starting on 0, okay?

938
01:53:56.720 --> 01:54:05.910
Francisco.Ortin@cit.ie: So, we're not considering the tabular, and the column for us is going to be something like getCarPositionInLine plus 1, okay? Because this method starts in 0.

939
01:54:05.910 --> 01:54:23.400
Francisco.Ortin@cit.ie: The only weird thing about this long name is because of tabular, okay? To make it simpler. And very important, this method here, do you remember I told you, okay, sometimes we're gonna have both the token and we need the Lexim, the additional strings that were used.

940
01:54:23.540 --> 01:54:25.399
Francisco.Ortin@cit.ie: So I'm gonna go back, sorry.

941
01:54:25.960 --> 01:54:27.610
Francisco.Ortin@cit.ie: So that you remember.

942
01:54:27.990 --> 01:54:29.859
Francisco.Ortin@cit.ie: Here, I told you…

943
01:54:30.370 --> 01:54:44.150
Francisco.Ortin@cit.ie: that we're gonna need identifier as a token, and then this extra string to tell me what's the actual Lexing, all right? So that's obtained with… oops, that's obtained with, get,

944
01:54:44.540 --> 01:54:46.980
Francisco.Ortin@cit.ie: text method, okay? GetText method.

945
01:54:47.550 --> 01:54:56.090
Francisco.Ortin@cit.ie: And that's it. If you have a constructor for passing the stream, and then you create a list. So if you put it all together, and you've described

946
01:54:56.160 --> 01:55:09.100
Francisco.Ortin@cit.ie: you've described your lecture here, and you get this class. Now the last slide in today's lecture is showing you how to use this without a parser. How can I instantiate this with an object, and then call it?

947
01:55:09.190 --> 01:55:11.149
Francisco.Ortin@cit.ie: Okay, so first you create

948
01:55:11.310 --> 01:55:23.209
Francisco.Ortin@cit.ie: this stream from the input, because you may read from different streams, okay, like in memory, in file, and so on, and then you create the lecture with a constructor. You pass a stream you just created.

949
01:55:23.570 --> 01:55:34.870
Francisco.Ortin@cit.ie: Okay, so what we're gonna do is just call in next token in an iteration, in a loop, in a while loop, and show… well, until no more tokens are available.

950
01:55:35.180 --> 01:55:37.460
Francisco.Ortin@cit.ie: And then show information about the token.

951
01:55:37.730 --> 01:55:40.759
Francisco.Ortin@cit.ie: So the information is going to be first the line of the token.

952
01:55:41.560 --> 01:55:48.519
Francisco.Ortin@cit.ie: Then the column, which is get compositioning line plus one. Then the actual lexin that has been,

953
01:55:48.700 --> 01:55:56.560
Francisco.Ortin@cit.ie: detected, so we have a… an identifier could be my variable, and if we have an ink constant, it could be 132.

954
01:55:56.660 --> 01:56:15.270
Francisco.Ortin@cit.ie: And then, finally, the name of the token. This name of the token, this is not important, I have not displayed, and this is only for this slide, and you will have to use in Lab 3 and nowhere else. It's just displaying the name, instead of the value, the integer value of ID, which could be, I don't know, 280,

955
01:56:15.300 --> 01:56:29.689
Francisco.Ortin@cit.ie: it displays the ID string, okay, so that you visually see that it's not a number and go to a table, you see that it's identifier ID, okay? It's just for, debugging purposes, okay? So we're not going to use it just in this Lab 3 slide.

956
01:56:29.780 --> 01:56:35.520
Francisco.Ortin@cit.ie: All right? And that's an example use of the token you generate. So next, next,

957
01:56:35.610 --> 01:56:51.880
Francisco.Ortin@cit.ie: week, we're going to practice with Antler, see how it works, and do some activities, so that you go to Lab 3 and design and implement your own Lexer, okay? So if you have any questions, we can leave it here, and I wish you a nice week, and see you on next Wednesday.

958
01:56:52.380 --> 01:56:53.040
Francisco.Ortin@cit.ie: Okay?

959
01:56:53.460 --> 01:56:54.299
Francisco.Ortin@cit.ie: Thank you very…

960
01:56:56.570 --> 01:56:58.180
Rudolf Adamkovič: Thank you.

961
01:56:58.460 --> 01:56:59.420
Dmitrijs Dubrovs: Thank you.

962
01:57:00.060 --> 01:57:01.299
Lilit Khachatryan: Thank you very much.

